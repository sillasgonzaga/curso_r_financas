[
["index.html", "Tópicos de Finanças com R Boas-vindas Sobre os instrutores", " Tópicos de Finanças com R Sillas Gonzaga e Wilson Freitas 2020-12-10 Boas-vindas Tópicos de Finanças com R tenta aproximar o mundo financeiro da linguagem de programação R. O mercado financeiro é um parque de diversões para profissionais com interesse em programação e em análise de dados. Há um grande volume de dados disponível online onde qualquer um pode ter acesso e realizar análises. Infelizmente a análise de dados financeiros não é trivial, é necessário algum conhecimento do problema para entrar nesse mundo, mas isso não é diferente de qualquer outra area do conhecimento. Este material tenta começar a preencher este hiato. Trazemos aqui fundamentais para o estudo de finanças e análise de dados, como: estruturas de dados para processamento, onde conseguir os dados, visualização de dados e alguns modelos. Há diversos exercícios para tornar a jornada o mais aplicada possível. Esperamos que aproveitem o conteúdo e boas análises. Sobre os instrutores Sillas Gonzaga Sillas é sou apaixonado pelo R. Pratica essa linguagem desde 2014 e, desde então, criou o blog chamado Paixão por Dados, já ministrou palestras sobre sua carreira com R e já publicou 4 pacotes R. Wilson Freitas Wilson Freitas é pai, padeiro amador e corredor de rua. Profissionalmente trabalha como Quant (especialista em modelagem quantitativa em finanças) no mercado financeiro desde 2007, onde passou por diversas instituições (Itaú, B3, ModalMais, etc.). Gosta de programar quando não está correndo nem fazendo pão e sempre contribuiu com o software livre desenvolvendo pacotes para as linguagens de programação e escrevendo posts no seu blog. Mantém uma conta ativa no Github (@wilsonfreitas) com mais de 50 repositórios de sua autoria. "],
["intro.html", "Capítulo 1 Primeiros passos com R 1.1 O que é R e por que devo aprendê-lo? 1.2 Introdução ao Rstudio 1.3 Operações aritméticas 1.4 Criação de variáveis e objetos 1.5 Estruturas de dados 1.6 Operadores de comparação 1.7 Conversões de tipos de variáveis 1.8 Vetores 1.9 Matrizes 1.10 Data frames 1.11 Funções 1.12 Pacotes 1.13 Exercícios", " Capítulo 1 Primeiros passos com R O material deste módulo introdutóri foi adaptado do excelente material didático Ciência de Dados com R - Introdução. 1.1 O que é R e por que devo aprendê-lo? R é uma linguagem de programação estatística que vem passando por diversas evoluções e se tornando cada vez mais uma linguagem de amplos objetivos. Podemos entender o R também como um conjunto de pacotes e ferramentas estatísticas, munido de funções que facilitam sua utilização, desde a criação de simples rotinas até análises de dados complexas, com visualizações bem acabadas. Segue alguns motivos para aprender-se R: É completamente gratuito e de livre distribuição; Curva de aprendizado bastante amigável, sendo muito fácil de se aprender; Enorme quantidade de tutoriais e ajuda disponíveis gratuitamente na internet; É excelente para criar rotinas e sistematizar tarefas repetitivas; Amplamente utilizado pela comunidade acadêmica e pelo mercado; Quantidade enorme de pacotes, para diversos tipos de necessidades; Ótima ferramenta para criar relatórios e gráficos. Apenas para exemplificar-se sua versatilidade, este eBook e os slides das aulas foram todos feitos em R. 1.2 Introdução ao Rstudio O R puro se apresenta como uma simples “tela preta” com uma linha para inserir comandos. Isso é bastante assustador para quem está começando e bastante improdutivo para quem já faz uso intensivo da ferramenta. Felizmente existe o RStudio, ferramenta auxiliar que usaremos durante todo o curso. Entenda o RStudio como uma interface gráfica com diversas funcionalidades que melhoram ainda mais o uso e aprendizado do R. Na prática, o RStudio facilita muito o dia a dia de trabalho. Portanto, desde já, ao falarmos em R, falaremos automaticamente no RStudio. Essa é a “cara” do RStudio: Figure 1.1: RStudio se divide em 4 partes Repare que, além da barra de menu superior, o RStudio é divido em quatro partes principais: Editor de Código No editor de código, você poderá escrever e editar os scripts. Script nada mais é do que uma sequência de comandos/ordens que serão executados em sequência pelo R. O editor do RStudio oferece facilidades como organização dos comandos, “auto-complete” de comandos, destaque da sintaxe dos comandos etc. Provavelmente é a parte que mais utilizaremos. Console É no console que o R mostrará a maioria dos resultados dos comandos. Também é possível escrever os comandos diretamente no console, sem o uso do editor de código. É muito utilizado para testes e experimentos rápidos. Um uso rápido do console é, por exemplo, chamar a ajuda do R usando o comando ? (isso mesmo, a interrogação é um comando!). Voltaremos a falar deste comando ? em breve. Environment e History No Environment ficarão guardados todos os objetos que forem criados na sessão do R. Entenda sessão como o espaço de tempo entre o momento em que você inicia o R e o momento em que finaliza. Neste período, tudo que você faz usa memória RAM e o processador do computador. E na aba History, como você deve imaginar, o RStudio cria um histórico de comandos utilizados. Files, Plots, Packages, Help e Viewer. Nesta janela, estão várias funcionalidades do RStudio. Na aba Files, você terá uma navegação de arquivos do seu computador. Também será possível definir o diretório de trabalho (você também pode definir diretamente no código, mas isto será tratado posteriormente), ou seja, o R entende o seu diretório de trabalho como ponto de partida para localizar arquivos que sejam chamados no script. 4.1 Aba Plots A aba Plots trará os gráficos gerados, possibilitando a exportação para alguns formatos diferentes, como .png e .pdf. 4.2 Aba Packages Em Packages estão listados os pacotes instalados. Você pode verificar quais estão carregados e, caso necessário, poderá carregar algum pacote necessário para a sua análise. Também é possível instalar e atualizar pacotes. Novamente, tudo isto é possível fazer diretamente no código. 4.3 Aba Help O nome já diz tudo. Esta aba será bastante utilizada por você. Saber usar o help é fundamental para evitar desperdício de tempo. Os usuários de R, em geral, são bastante solícitos. Entretanto, uma olhadinha rápida no help pode evitar que você gaste “créditos” desnecessariamente. 4.4 Aba Viewer Por fim, o Viewer. Esta funcionalidade é utilizada para visualizar-se localmente conteúdo web. O gráfico da figura está na aba Viewer porque é uma visualização em javascript, que pode ser adicionada a documentos html gerados usando o RMarkdown ou em aplicações web com suporte do Shiny. 1.3 Operações aritméticas O R pode ser usado como uma simples calculadora para fazer operações matemáticas simples: 4 + 5 ## [1] 9 2 - 3 ## [1] -1 4 * 8 ## [1] 32 1 / 3 ## [1] 0.3333333 2 ^ 5 ## [1] 32 4 %% 3 ## [1] 1 9 %/% 2 ## [1] 4 1.4 Criação de variáveis e objetos Para que o R deixe de ser uma simples calculadora, será necessário aprender, dentre outras coisas, o uso de variáveis. Se você tem alguma noção de estatística, provavelmente já tem a intuição do que é uma variável para uma linguagem de programação. No contexto do R, vamos entender variável como um objeto, ou seja, como uma estrutura predefinida que vai “receber” algum valor. Utilizando uma linguagem mais técnica, objeto (ou variável) é um pequeno espaço na memória do seu computador onde o R armazenará um valor ou o resultado de um comando, utilizando um nome que você mesmo definiu. Conhecer os tipos de objetos do R é fundamental. Para criar objetos, utiliza-se o símbolo &lt;-. Este provavelmente é o símbolo que você mais verá daqui para frente. Execute, no console ou no editor de códigos, o seguinte comando x &lt;- 15. Pronto, agora o nome x representa o valor 15. Para comprovar, execute apenas o nome do objeto x, o R mostrará o conteúdo dele. A partir de então, você poderá utilizar esse objeto como se fosse o valor 15. Experimente os seguintes resultados: x + 5 x * x / 2 2 ^ x y &lt;- x / 3 Dê uma boa lida em Dicas e boas práticas para um código organizado para aprender a organizar seus objetos e funções da melhor maneira possível. Todos os objetos que você criar estarão disponíveis na aba Environment. O RStudio possui a função auto complete. Digite as primeiras letras de um objeto (ou função) que você criou e, em seguida, use o atalho ctrl + barra de espaço. O RStudio listará tudo que começar com essas letras no arquivo. Selecione algum item e aperte enter para escrevê-lo no editor de códigos. 1.5 Estruturas de dados Existem diversos tipos de objetos, e cada tipo “armazena” um conteúdo diferente, desde tabelas de dados recém-carregados a textos, números, ou simplesmente a afirmação de verdadeiro ou falso (Boleano). inteiro &lt;- 928 outro.inteiro &lt;- 5e2 decimal &lt;- 182.93 caracter &lt;- &#39;exportação&#39; logico &lt;- TRUE outro.logico &lt;- FALSE Repare nas atribuições acima. Usaremos a função class() para ver o tipo de cada uma: class(inteiro) ## [1] &quot;numeric&quot; class(outro.inteiro) ## [1] &quot;numeric&quot; class(decimal) ## [1] &quot;numeric&quot; class(caracter) ## [1] &quot;character&quot; class(logico) ## [1] &quot;logical&quot; class(outro.logico) ## [1] &quot;logical&quot; Esses são alguns dos tipos básicos de objetos/variáveis no R. Para valores inteiros ou decimais, numeric , character para valores textuais e logical para valores lógicos (verdadeiro ou falso). Existe também o tipo integer, que representa apenas números inteiros, sem decimais, porém, na maioria das vezes, o R interpreta o integer como numeric, pois o integer também é um numeric. Além dos tipos básicos, existem também os tipos “complexos”, que são vector, array, matrix, list, data.frame e factor. 1.6 Operadores de comparação Em todas as comparações do R usamos operadores lógicos. São operações matemáticas em que o resultado é TRUE ou FALSE (tipo logical). Para melhor entendimento, selecionamos alguns operadores lógicos e seus significados: == igual a: compara dois objetos e se forem iguais retorna TRUE, caso contrário, FALSE; != diferente: compara dois objetos e se forem diferentes retorna TRUE, caso contrário, FALSE; | ou (or): compara dois objetos, se um dos dois for TRUE, retorna TRUE, se os dois forem FALSE, retorna FALSE; &amp; e (and): compara dois objetos, se os dois forem TRUE, retorna TRUE, se um dos dois ou os dois forem FALSE, retorna FALSE; &gt;, &gt;=, &lt;, &lt;= maior, maior ou igual, menor, menor ou igual: compara grandeza de dois números e retorna TRUE ou FALSE conforme a condição; Vejamos alguns exemplos de comparação: 1 &gt; 2 ## [1] FALSE &quot;b&quot; &gt; &quot;a&quot; ## [1] TRUE 0 &lt; -1 ## [1] FALSE 1 != 2 ## [1] TRUE 0 == FALSE ## [1] TRUE 1 != TRUE ## [1] FALSE (4 &gt; 5) | (1 &lt; 2) ## [1] TRUE (4 &gt; 5) &amp; (1 &lt; 2) ## [1] FALSE 2 &gt;= 2 ## [1] TRUE 1.7 Conversões de tipos de variáveis Quando é feito o carregamento de algum arquivo de dados no R, ele tenta “deduzir” os tipos de dados de cada coluna. Nem sempre essa dedução sai correta e, eventualmente, você precisará converter de um tipo para o outro. O R tem algumas funções para fazer essas conversões. class(&quot;2015&quot;) ## [1] &quot;character&quot; as.numeric(&quot;2015&quot;) ## [1] 2015 class(55) ## [1] &quot;numeric&quot; as.character(55) ## [1] &quot;55&quot; class(3.14) ## [1] &quot;numeric&quot; as.integer(3.14) ## [1] 3 as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE O R também tenta “forçar a barra”, às vezes, para te ajudar. Quando você faz uma operação entre dois tipos diferentes, ele tenta fazer algo chamado coerção de tipos, ou seja, ele tenta converter os dados para que a operação faça sentido. Caso o R não consiga fazer a coerção, ele vai mostrar uma mensagem de erro. Experimente os comandos a seguir no console: 7 + TRUE 2015 &gt; &quot;2016&quot; &quot;2014&quot; &lt; 2017 # em alguns casos a coerção irá falhar ou dar resultado indesejado 6 &gt; &quot;100&quot; &quot;6&quot; &lt; 5 1 + &quot;1&quot; Recomendamos fortemente que sempre se realize as conversões explicitamente com as funções apropriadas ao invés de confiar na coerção do R, a não ser que se tenha certeza do resultado. 1.8 Vetores Vetores são sequências unidimensionais de valores de um mesmo tipo: #faça as seguintes atribuições vetor.chr &lt;- c(&#39;tipo1&#39;, &#39;tipo2&#39;, &#39;tipo3&#39;, &#39;tipo4&#39;) vetor.num &lt;- c(1, 2, 5, 8, 1001) vetor.num.repetidos &lt;- c(rep(2, 50)) #usando funcão para repetir números vetor.num.sequencia &lt;- c(seq(from=0, to=100, by=5)) #usando função para criar sequências vetor.logical &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE) ##veja o conteúdo das variáveis vetor.chr ## [1] &quot;tipo1&quot; &quot;tipo2&quot; &quot;tipo3&quot; &quot;tipo4&quot; vetor.num ## [1] 1 2 5 8 1001 vetor.num.repetidos ## [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## [39] 2 2 2 2 2 2 2 2 2 2 2 2 vetor.num.sequencia ## [1] 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 ## [20] 95 100 vetor.logical ## [1] TRUE TRUE TRUE FALSE FALSE Para a criação de vetores, usamos a função de combinação de valores c() (combine). Esta função vai combinar todos os parâmetros em um único vetor. Lembre-se: vetores são sequências que contêm apenas um tipo de dado. Para retornar (extrair) um ou mais elementos de um vetor, usa-se colchetes: vetor &lt;- c(seq(from=0, to=100, by=15)) #vetor de 0 a 100, de 15 em 15. vetor #lista todos os elementos ## [1] 0 15 30 45 60 75 90 vetor[1] #mostra apenas o elemento na posição 1 ## [1] 0 vetor[2] #apenas o elemento na posição 2 ## [1] 15 vetor[7] #apenas o elemento na posição 7 ## [1] 90 vetor[8] #não existe nada na posição 8... ## [1] NA vetor[c(2,7)] #selecionando mais de um elemento no vetor ## [1] 15 90 Pode-se usar até lógica de programação para retornar elementos de um vetor de acordo com algum teste lógico: vetor[vetor &lt; 20] ## [1] 0 15 vetor[vetor %% 2 == 0] ## [1] 0 30 60 90 1.9 Matrizes Matrizes são estruturas de dados bidimensionais: linhas e colunas. Assim como vetores, matrizes podem possuir dados de apenas uma classe (numeric ou character). # criando uma matriz a partir de vetores v1 &lt;- c(1, 2, 3) v2 &lt;- c(4, 5, 6) v3 &lt;- c(7, 8, 9) matriz &lt;- cbind(v1, v2, v3) matriz ## v1 v2 v3 ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 class(matriz) ## [1] &quot;matrix&quot; &quot;array&quot; Matrizes também podem ser indexadas com colchetes, com a diferença que é preciso especificar o elemento da linha e o da coluna: matriz[1, ] ## v1 v2 v3 ## 1 4 7 matriz[, 2] ## [1] 4 5 6 matriz[1:2, 3] ## [1] 7 8 matriz[1, 3] ## v3 ## 7 1.10 Data frames Data frame é, provavelmente, o tipo de dado complexo mais utilizado em R. É nele que você armazena conjuntos de dados estruturados em linhas e colunas. Um data frame possui colunas nomeadas, sendo que todas as colunas possuem a mesma quantidade de linhas. Imagine o dataframe como uma tabela em que cada coluna corresponde a um vetor. Conhecendo o data.frame e o vector, você será capaz de entender como os dois se relacionam. Cada coluna de um data frame é um vetor. Um data frame pode ter colunas de diferentes tipos, mas cada coluna só pode ter registros de um único tipo. Ficará mais claro a seguir. Veja como se cria um data.frame: #cria-se diferentes vetores nome &lt;- c(&#39;João&#39;, &#39;José&#39;, &#39;Maria&#39;, &#39;Joana&#39;) idade &lt;- c(45, 12, 28, 31) adulto &lt;- c(TRUE, FALSE, TRUE, TRUE) uf &lt;- c(&#39;DF&#39;, &#39;SP&#39;, &#39;RJ&#39;, &#39;MG&#39;) #cada vetor é uma combinação de elementos de um MESMO tipo de dados #sendo assim, cada vetor pode ser uma coluna de um data.frame clientes &lt;- data.frame(nome, idade, adulto, uf) clientes ## nome idade adulto uf ## 1 João 45 TRUE DF ## 2 José 12 FALSE SP ## 3 Maria 28 TRUE RJ ## 4 Joana 31 TRUE MG str(clientes) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ nome : chr &quot;João&quot; &quot;José&quot; &quot;Maria&quot; &quot;Joana&quot; ## $ idade : num 45 12 28 31 ## $ adulto: logi TRUE FALSE TRUE TRUE ## $ uf : chr &quot;DF&quot; &quot;SP&quot; &quot;RJ&quot; &quot;MG&quot; 1.11 Funções Entenda função como uma sequência de comandos preparados para serem usados de forma simples e, assim, facilitar sua vida. Funções são usadas para tudo que você possa imaginar: cálculos mais complexos, estatística, análise de dados, manipulação de dados, gráficos, relatórios etc. Assim que você o instala, o R já vem configurado com várias funções prontas para uso. A partir de agora, chamaremos esse conjunto de funções que já vem por padrão com o R de R Base. Claro que as funções do R base não serão suficientes para resolver todos os problemas que você encontrará pela frente. Nesse sentido, o R também mostra outro ponto forte. Você pode instalar conjuntos extras de funções específicas de maneira muito simples: usando pacotes. Funcões do R base. raiz.quadrada &lt;- sqrt(16) # função para calcular raiz quadrada round(5.3499999, 2) # função para arredondamento Uma função tem dois elementos básicos: o nome e o(s) parâmetro(s) (também chamados de argumentos). Por exemplo, a função log(10) possui o nome log() e apenas um parâmetro, que é o número que você quer calcular o log. Já a função round() possui dois parâmetros, o número que você quer arredondar e a quantidade de dígitos para arredondamento. Quando você usa uma função, você pode informar os parâmetros de duas formas: sequencialmente, sem explicitar o nome dos parâmetros, ou na ordem que quiser, explicitando o nome dos parâmetros. Veja o exemplo a seguir: round(5.3499999, 2) # o mesmo que: round(digits = 2, x = 5.3499999) Para saber como informar os parâmetros corretamente, utilize o comando ? (ou coloque o cursor no nome da função e pressione F1) para ver a documentação de funções, ou seja, conhecer para que serve, entender cada um dos seus parâmetros e ver exemplos de uso. ?round ?rnorm ??inner_join # procurar ajuda de funções que não estão &quot;instaladas&quot; ainda Vale comentar que é possível informar objetos nos parâmetros das funções. x &lt;- 3.141593 round(x, 3) ## [1] 3.142 ceiling(x) ## [1] 4 floor(x) ## [1] 3 Observe algumas das principais funções para estatísticas básicas no R: Função R Estatística sum() Soma de valores mean() Média var() Variância median() Mediana summary() Resumo Estatístico quantile() Quantis 1.12 Pacotes Como dito antes, pacotes são conjuntos extras de funções que podem ser instalados além do R base. Existem pacotes para auxiliar as diversas linhas de estudo que você possa imaginar: estatística, econometria, ciências sociais, medicina, biologia, gráficos, machine learning etc. Caso você precise de algum pacote específico, procure no Google pelo tema que necessita. Você encontrará o nome do pacote e o instalará normalmente. Nesse link você pode ver uma lista de todos os pacotes disponíveis no repositório central. Além desses, ainda existe a possibilidade de instalar-se pacotes “não oficiais”, que ainda não fazem parte de um repositório central. Para instalar um pacote, execute o seguinte comando: install.packages(&quot;dplyr&quot;) # instala um famoso pacote de manipulação de dados Uma vez instalado, esse pacote estará disponível para uso sempre que quiser, sem a necessidade de instalá-lo novamente. Mas, sempre que iniciar um código novo, você precisará carregá-lo na memória. Para isso, use o seguinte comando: library(dplyr) Para instalar um pacote, você precisa informar o nome entre aspas install.packages(“readxl”), caso contrário o pacote não funcionará. Porém, para carregar o pacote em memória, você pode usar com ou sem aspas library(readxl) ou library(“readxl”), ambas as formas funcionam. 1.13 Exercícios Dado o vetor de retornos abaixo, use as funções summary() e sd() para calcular algumas estatísticas relevantes: retornos &lt;- c(0.0102, 0.00186, -0.00635, 0.0193, 0.00203, -0.01846, 0.00434, -0.01256, -0.00944, -0.00087) "],
["novos-passos-com-r-part2.html", "Capítulo 2 Novos passos com R {part2} 2.1 Leitura de arquivos csv 2.2 Gráficos com ggplot2 2.3 Trabalhando com datas 2.4 ‘Parsear’ datas e horários 2.5 Extrair componentes de uma data 2.6 Operações matemáticas com datas 2.7 If-else 2.8 Loops 2.9 Criado suas próprias funções 2.10 Listas 2.11 purrr::map 2.12 Case 1 2.13 Case 2", " Capítulo 2 Novos passos com R {part2} 2.1 Leitura de arquivos csv Para ler arquivos csv com o R, usamos o pacote readr, que faz parte do tidyverse. Caso as colunas do arquivo que se deseja ler sejam separadas por vírgula, usa-se a função readr::read_csv(). Caso o separador seja ponto e vírgula (o padrão brasileiro), usa-se readr::read_csv2(). Vamos ler o arquivo de exemplo deste módulo: library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 4.0.2 ## -- Attaching packages ------------------------------------------------------------------------------------------------------ tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.1 v dplyr 1.0.0 ## v tidyr 1.1.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## Warning: package &#39;ggplot2&#39; was built under R version 4.0.2 ## Warning: package &#39;tidyr&#39; was built under R version 4.0.2 ## Warning: package &#39;readr&#39; was built under R version 4.0.2 ## Warning: package &#39;dplyr&#39; was built under R version 4.0.2 ## Warning: package &#39;forcats&#39; was built under R version 4.0.2 ## -- Conflicts --------------------------------------------------------------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() df &lt;- readr::read_csv(&quot;abev3_petr4.csv&quot;) ## Parsed with column specification: ## cols( ## data = col_date(format = &quot;&quot;), ## petr4 = col_double(), ## abev3 = col_double(), ## retorno_diario_petr4 = col_double(), ## retorno_diario_abev3 = col_double() ## ) 2.2 Gráficos com ggplot2 O ggplot2 é uma poderosa ferramenta para fazer gráficos a partir de objetos da classe data.frame. Gráficos no R são um assunto bem extenso, e muito se poderia falar sobre o tema. Neste material, o pacote será apresentado de forma breve. Para um conteúdo mais abrangente sobre o tema, recomenda-se a leitura deste material. 2.2.1 Como usar o ggplot2: Gráficos no ggplot são feitos nesta sintaxe: ggplot(&lt;NOME DO DATAFRAME&gt;, aes(x = &lt;VARIAVEL DO EIXO X&gt;, y = &lt;VARIAVEL DO EIXO Y&gt;)) + &lt;TIPO DO GRÁFICO&gt; + &lt;CUSTOMIZAÇÕES EXTRAS&gt; 2.2.2 Gráfico de dispersão ou gráfico de pontos A sintaxe para se fazer um gráfico de pontos é: ggplot(df, aes(x = petr4, y = abev3)) + geom_point() ## Warning: Removed 3 rows containing missing values (geom_point). 2.2.3 Gráfico de linha A sintaxe para fazer um gráfico de linha é semelhante ao de pontos. Contudo, esse tipo de gráfico é mais usado quando a variável do eixo x é do tipo Date. ggplot(df, aes(x = data, y = petr4)) + geom_line() 2.2.4 Histogramas Os histogramas são utilizados para representar-se a distribuição de dados de uma variável quantitativa em intervalos contínuos. Esses intervalos são chamados de bins. Para cada bin, será apresentada a quantidade de valores que estão naquele intervalo. No mercado financeiro, uma aplicação comum de histogramas é analisar a distribuição de retornos diários de um ativo: ggplot(df, aes(x = retorno_diario_petr4)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 7 rows containing non-finite values (stat_bin). 2.3 Trabalhando com datas Datas são um caso a parte no R. Existe uma própria classe para objetos desse tipo, chamada Date, com D maiúsculo. O R lida com datas no formato AAAA-MM-DD (Ano, Mês e Dia). Abaixo, definimos um vetor com datas x &lt;- c(&quot;2014-07-15&quot;, &quot;2018/03/20&quot;, &quot;2019-12-31&quot;, &quot;20170511&quot;) as.Date(x) ## [1] &quot;2014-07-15&quot; NA &quot;2019-12-31&quot; NA class(as.Date(x)) ## [1] &quot;Date&quot; Perceba que o R nativamente não aceita qualquer separador entre o ano, o mês e o dia, apenas o traço. O pacote lubridate, que faz parte da família tidyverse, possui uma versão mais generalizável para isso: library(lubridate) ## Warning: package &#39;lubridate&#39; was built under R version 4.0.2 ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union lubridate::as_date(x) ## [1] &quot;2014-07-15&quot; &quot;2018-03-20&quot; &quot;2019-12-31&quot; &quot;2017-05-11&quot; A propósito, dominar o pacote lubridate, que possui funções muito simples de usar, é a única coisa necessária para saber lidar com datas no R. Por isso, vamos mostrar as principais funções do pacote. 2.3.1 Gerar um vetor sequencial de datas Essa tarefa é feita usando uma função nativa do R chamada seq.Date(), que possui quatro argumentos principais, sendo que três deles precisam ser especificados. args(seq.Date) ## function (from, to, by, length.out = NULL, along.with = NULL, ## ...) ## NULL # gerar vetor de datas separadas por mes seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-12-01&quot;), by = &quot;1 month&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-02-01&quot; &quot;2020-03-01&quot; &quot;2020-04-01&quot; &quot;2020-05-01&quot; ## [6] &quot;2020-06-01&quot; &quot;2020-07-01&quot; &quot;2020-08-01&quot; &quot;2020-09-01&quot; &quot;2020-10-01&quot; ## [11] &quot;2020-11-01&quot; &quot;2020-12-01&quot; # gerar vetor de datas separadas por dia seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;1 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-02&quot; &quot;2020-01-03&quot; &quot;2020-01-04&quot; &quot;2020-01-05&quot; ## [6] &quot;2020-01-06&quot; &quot;2020-01-07&quot; &quot;2020-01-08&quot; &quot;2020-01-09&quot; &quot;2020-01-10&quot; ## [11] &quot;2020-01-11&quot; &quot;2020-01-12&quot; &quot;2020-01-13&quot; &quot;2020-01-14&quot; &quot;2020-01-15&quot; ## [16] &quot;2020-01-16&quot; &quot;2020-01-17&quot; &quot;2020-01-18&quot; &quot;2020-01-19&quot; &quot;2020-01-20&quot; # gerar vetor de datas separadas por 3 dias seq.Date(from = as_date(&quot;2020-01-01&quot;), to = as_date(&quot;2020-01-20&quot;), by = &quot;3 day&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-04&quot; &quot;2020-01-07&quot; &quot;2020-01-10&quot; &quot;2020-01-13&quot; ## [6] &quot;2020-01-16&quot; &quot;2020-01-19&quot; # gerar um vetor de 7 semanas separados por 1 semana seq.Date(from = as_date(&quot;2020-01-01&quot;), length.out = 7, by = &quot;1 week&quot;) ## [1] &quot;2020-01-01&quot; &quot;2020-01-08&quot; &quot;2020-01-15&quot; &quot;2020-01-22&quot; &quot;2020-01-29&quot; ## [6] &quot;2020-02-05&quot; &quot;2020-02-12&quot; 2.4 ‘Parsear’ datas e horários Para fazer o R converter (ou parsear na linguagem de programação) um string em data, basta usar as funções correspondentes do lubridate. Por exemplo, no vetor de exemplo x, definido acima, as datas já estavam definidas no formato correto: AAAA-MM-DD. Aqui no Brasil usamos outro formato: DD/MM/AAAA. O lubridate possui uma função pronta para essa situação: # observer como usamos diferentes separadores datas_brasil &lt;- c(&quot;01/12/2019&quot;, &quot;20/11/2018&quot;, &quot;30011990&quot;, &quot;17-03-2000&quot;) # parseando o vetor acima para Data dmy(datas_brasil) ## [1] &quot;2019-12-01&quot; &quot;2018-11-20&quot; &quot;1990-01-30&quot; &quot;2000-03-17&quot; Caso o vetor também contenha dados de horário, basta incluir o sufixo referente a hora, minuto e segundo: dmy_hms(&quot;30-09-2019 14:51:39&quot;) ## [1] &quot;2019-09-30 14:51:39 UTC&quot; # sem o segundo dmy_hm(&quot;30-09-2019 14:15&quot;) ## [1] &quot;2019-09-30 14:15:00 UTC&quot; # apenas a hora dmy_h(&quot;30-09-2019 15&quot;) ## [1] &quot;2019-09-30 15:00:00 UTC&quot; 2.5 Extrair componentes de uma data É possível extrair qualquer tipo de componente de uma data ou de um vetor de datas com o lubridate. Veja alguns exemplos: datas_brasil &lt;- dmy_hms(c(&quot;01/12/2019 13:51:15&quot;, &quot;20/11/2018 00:00:00&quot;, &quot;30011990 080000&quot;, &quot;17-03-2000 203000&quot;)) datas_brasil ## [1] &quot;2019-12-01 13:51:15 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; ## [3] &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:30:00 UTC&quot; # extrair componentes da data: # ano year(datas_brasil) ## [1] 2019 2018 1990 2000 # mes month(datas_brasil) ## [1] 12 11 1 3 # dia day(datas_brasil) ## [1] 1 20 30 17 # semana do ano week(datas_brasil) ## [1] 48 47 5 11 # dia da semana wday(datas_brasil, label = TRUE) ## [1] dom ter ter sex ## Levels: dom &lt; seg &lt; ter &lt; qua &lt; qui &lt; sex &lt; sáb # trimestre quarter(datas_brasil) ## [1] 4 4 1 1 # hora hour(datas_brasil) ## [1] 13 0 8 20 2.6 Operações matemáticas com datas Geralmente se está interessado em fazer três tipos de operações matemáticas com datas: Adicionar uma quantidade N de dias/meses/anos/etc em uma data: # adicionar 1 semana nas datas datas_brasil + ddays(7) ## [1] &quot;2019-12-08 13:51:15 UTC&quot; &quot;2018-11-27 00:00:00 UTC&quot; ## [3] &quot;1990-02-06 08:00:00 UTC&quot; &quot;2000-03-24 20:30:00 UTC&quot; # adicionar 3 meses datas_brasil + ddays(90) ## [1] &quot;2020-02-29 13:51:15 UTC&quot; &quot;2019-02-18 00:00:00 UTC&quot; ## [3] &quot;1990-04-30 08:00:00 UTC&quot; &quot;2000-06-15 20:30:00 UTC&quot; # adicionar 1 ano datas_brasil + dyears(1) ## [1] &quot;2020-11-30 19:51:15 UTC&quot; &quot;2019-11-20 06:00:00 UTC&quot; ## [3] &quot;1991-01-30 14:00:00 UTC&quot; &quot;2001-03-18 02:30:00 UTC&quot; Calcular a diferença de tempo entre duas datas: No R, subtrair datas segue a mesma sintaxe de subtrair números: data1 &lt;- dmy_hms(&quot;01/09/1993 20:00:00&quot;) data2 &lt;- dmy_hms(&quot;24-06-2018 17:00:00&quot;) dif &lt;- data2 - data1 dif ## Time difference of 9061.875 days Por padrão, o R retorna a diferença em dias, mas em um objeto de classe difftime. class(dif) ## [1] &quot;difftime&quot; Recomenda-se então converter o output para a classe numeric: as.numeric(dif) ## [1] 9061.875 Caso se deseje calcular essa diferença em outras unidades de tempo, como meses ou semanas, basta fazer a divisão correspondente: # conveter para semanas as.numeric(dif) / 7 ## [1] 1294.554 # converter para meses as.numeric(dif) / 30 ## [1] 302.0625 # converter para anos as.numeric(dif) / 365 ## [1] 24.82705 Arredondar datas: Para arredondar uma data, por exemplo, retornar o primeiro ou último dia da semana/mês/trimestre/etc de uma data de referência, usa-se as funções ceiling_date() (arredondar para cima) e floor_date() (para baixo): # retornar a primeira data da semana: floor_date(datas_brasil, &quot;week&quot;) ## [1] &quot;2019-12-01 UTC&quot; &quot;2018-11-18 UTC&quot; &quot;1990-01-28 UTC&quot; &quot;2000-03-12 UTC&quot; # retornar a ultima data do mês # por padrao, ceiling_date retorna a primeira data do próximo mês, # por isso é necessario subtrair o resultado por 1 ceiling_date(datas_brasil, &quot;month&quot;) - 1 ## [1] &quot;2019-12-31 23:59:59 UTC&quot; &quot;2018-11-30 23:59:59 UTC&quot; ## [3] &quot;1990-01-31 23:59:59 UTC&quot; &quot;2000-03-31 23:59:59 UTC&quot; # arredondar usando a hora como referencia floor_date(datas_brasil, &quot;hour&quot;) ## [1] &quot;2019-12-01 13:00:00 UTC&quot; &quot;2018-11-20 00:00:00 UTC&quot; ## [3] &quot;1990-01-30 08:00:00 UTC&quot; &quot;2000-03-17 20:00:00 UTC&quot; 2.7 If-else A estrutura condicional é algo bastante intuitivo. A estrutura de if (se) e else (então) usa os operadores lógicos apresentados anteriormente. Se a condição do if() for verdadeira, executa-se uma tarefa específica, se for falsa, executa-se uma tarefa diferente. A estrutura parece algo do tipo: if( variavel &gt;= 500 ) { #executa uma tarefa se operação resultar TRUE } else { #executa outra tarefa se operação resultar FALSE } Da mesma forma, existe uma função que gera o mesmo resultado, o ifelse() (e uma do pacote dplyr, o if_else()). ifelse(variavel &gt;= 500, &#39;executa essa tarefa se TRUE&#39;, &#39;executa outra se FALSE&#39;) Existe uma diferença entre as duas formas de “if else”: a estrutura if() {} else {} só opera variáveis, uma por uma, já a estrutura ifelse() opera vetores, ou seja, consegue fazer a comparação para todos os elementos. Isso faz com que a forma if() {} else {} seja mais utilizada para comparações fora dos dados, com variáveis avulsas. Já a estrutura ifelse() é mais usada para comparações dentro dos dados, com colunas, vetores e linhas. Qualquer uma dessas estruturas pode ser “aninhada”, ou seja, encadeada. Por exemplo: a &lt;- 9823 if(a &gt;= 10000) { b &lt;- &#39;VALOR ALTO&#39; } else if(a &lt; 10000 &amp; a &gt;= 1000) { b &lt;- &#39;VALOR MEDIO&#39; } else if(a &lt; 1000) { b &lt;- &#39;VALOR BAIXO&#39; } b ## [1] &quot;VALOR MEDIO&quot; Ou ainda: a &lt;- 839 c &lt;- ifelse(a &gt;= 10000, &#39;VALOR ALTO&#39;, ifelse(a &lt; 10000 &amp; a &gt;= 1000, &#39;VALOR MEDIO&#39;, &#39;VALOR BAIXO&#39;)) c ## [1] &quot;VALOR BAIXO&quot; 2.8 Loops Trata-se de um dos conceitos mais importantes de qualquer linguagem de programação, em R não é diferente. Loops (ou laços) repetem uma sequência de comando quantas vezes você desejar, ou até que uma condição aconteça, variando-se alguns aspectos entre uma repetição e outra. Supondo que você tenha que ler 400 arquivos de dados que você obteve de um cliente. Você vai escrever 400 vezes a funcão de leitura? Nesse caso, basta fazer um loop para percorrer todos os arquivos da pasta e ler um por um com a função de leitura. O for() é usado para realizar uma série de ordens para uma determinada sequência ou índices (vetor). Sua sintaxe é bem simples: for(i in c(1, 2, 3, 4, 5)) { print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 25 Para cada valor (chamamos esse valor de i) dentro do vetor c(1, 2, 3, 4, 5), execute o comando print(i^2). Qualquer outro comando dentro das chaves { ... } seria executado para cada valor do vetor. Para entendermos melhor, vamos repensar o exemplo das séries usando o for(). lista.de.arquivos &lt;- list.files(&#39;dados/dados_loop&#39;) #lista todos os arquivos de uma pasta is.vector(lista.de.arquivos) ## [1] TRUE for(i in lista.de.arquivos) { print(paste(&#39;Leia o arquivo:&#39;, i)) #exemplo: read_delim(i, delim = &quot;|&quot;) } Também é possível utilizar loop com if. No exemplo a seguir, queremos ver todos os números de 1 a 1000 que são divisíveis por 29 e por 3 ao mesmo tempo. Para isso, utilizaremos o operador %%, que mostra o resto da divisão. Se o resto for zero, é divisível. for(i in 1:1000){ if((i %% 29 == 0) &amp; (i %% 3 == 0)){ print(i) } } ## [1] 87 ## [1] 174 ## [1] 261 ## [1] 348 ## [1] 435 ## [1] 522 ## [1] 609 ## [1] 696 ## [1] 783 ## [1] 870 ## [1] 957 2.9 Criado suas próprias funções Funções “encapsulam” uma sequência de comandos e instruções. É uma estrutura nomeada, que recebe parâmetros para iniciar sua execução e retorna um resultado ao final. Até o momento, você já usou diversas funções. Vejamos então como criar uma função: sua_funcao &lt;- function(parametro1, parametro2){ # sequência de tarefas return(valores_retornados) } # chamada da função sua_funcao Por exemplo, vamos criar uma função que, dado uma série temporal de retornos, exibe algumas estatísticas: analisar_retorno &lt;- function(x){ # x é um nome qualquer que, no escopo da função, diz respeito ao objeto # que será passado como input print(&quot;Média: &quot; ) print(mean(x)) print(&quot;Desvio padrão: &quot;) print(sd(x)) print(&quot;Mediana: &quot;) print(median(x)) } Vamos então aplicar às séries de retorno do nosso dataset: analisar_retorno(df$retorno_diario_petr4) ## [1] &quot;Média: &quot; ## [1] NA ## [1] &quot;Desvio padrão: &quot; ## [1] NA ## [1] &quot;Mediana: &quot; ## [1] NA Veja que é necessário alterar o corpo da função para que as funções ignorem a presença de NAs nos dados. analisar_retorno &lt;- function(x){ # x é um nome qualquer que, no escopo da função, diz respeito ao objeto # que será passado como input print(&quot;Média: &quot; ) print(mean(x, na.rm = TRUE)) print(&quot;Desvio padrão: &quot;) print(sd(x, na.rm = TRUE)) print(&quot;Mediana: &quot;) print(median(x, na.rm = TRUE)) } Agora sim: analisar_retorno(df$retorno_diario_abev3) ## [1] &quot;Média: &quot; ## [1] 0.0002691528 ## [1] &quot;Desvio padrão: &quot; ## [1] 0.01713899 ## [1] &quot;Mediana: &quot; ## [1] 0 analisar_retorno(df$retorno_diario_petr4) ## [1] &quot;Média: &quot; ## [1] 0.001309632 ## [1] &quot;Desvio padrão: &quot; ## [1] 0.03378723 ## [1] &quot;Mediana: &quot; ## [1] 0.001014129 2.10 Listas Nós já falamos sobre vetores, que são as principais estruturas unidimensionais de dados e que só aceitam elementos da mesma classe: a &lt;- c(1, 2, &quot;c&quot;, 4) class(a) ## [1] &quot;character&quot; O R também possui uma estrutura de dados que pode armazenar, literalmente, qualquer tipo de objeto: as listas, criadas com a função list(). No exemplo abaixo uma série de objetos de classes diferentes são armazenadas: data_frame &lt;- head(iris) elemento_unico_inteiro &lt;- 1 um_na &lt;- NA vetor_string &lt;- letters[1:5] minha_lista &lt;- list(data_frame = data_frame, elemento_unico_inteiro = elemento_unico_inteiro, # este elemento abaixo não vai possuir um nome um_na, vetor_string = vetor_string) # Conferindo o output: minha_lista ## $data_frame ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## ## $elemento_unico_inteiro ## [1] 1 ## ## [[3]] ## [1] NA ## ## $vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Pelo output já percebemos que a maneira como extraímos um elemento de um vetor é diferente da de uma lista. No primeiro, usamos um par de colchetes ([]), no segundo usamos dois pares ([[]]) ou também cifrão ($), que só funciona caso o elemento da lista possua um nome. minha_lista[[2]] ## [1] 1 minha_lista$vetor_string ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; # o comando abaixo retorna NULL pq &quot;um_na&quot; não é um nome de # nenhum elemento da lista minha_lista$um_na ## NULL A maneira mais produtiva de se usar listas em seus projetos é para automatizar a aplicação de uma determinada função (ou funções) para todos os elementos de uma lista. Suponha, por exemplo, que você precise importar dezenas de arquivos csv, fazer algumas limpezas e manipulações de dados, construir modelos de Machine Learning e depois salvar os resultados no computador. Seria muito tedioso fazer isso manualmente, mas é para esse tipo de operação que listas se tornam muito úteis. O pacote purrr possui uma série de comandos para aplicar funções a elementos de uma lista. O R base até possui as funções da família apply (apply(), tapply(), lapply(), etc), mas estas estão entrando em desuso devido à adoção do purrr. 2.11 purrr::map Nós já vimos que o R aplica uma função a cada elemento de um vetor de uma forma muito simples: meu_vetor &lt;- c(1, -3, 5, -10) # extrair o modulo de cada elemento do vetor acima abs(meu_vetor) ## [1] 1 3 5 10 No caso de listas, não é bem assim que funciona: minha_lista &lt;- list(1, 3, 5, 10) abs(minha_lista) ## Error in abs(minha_lista): non-numeric argument to mathematical function É necessário usar uma outra função para aplicar uma função a cada elemento da lista. É aqui que introduzimos a função map(), do pacote purrr. O primeiro argumento é a estrutura de dados sobre a qual se deseja iterar e o segundo é a função que será aplicada a cada elemento. O pacote purrr faz parte do tidyverse. library(tidyverse) library(purrr) map(minha_lista, abs) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 3 ## ## [[3]] ## [1] 5 ## ## [[4]] ## [1] 10 Veja a diferença no output: class(minha_lista) ## [1] &quot;list&quot; map(minha_lista, class) ## [[1]] ## [1] &quot;numeric&quot; ## ## [[2]] ## [1] &quot;numeric&quot; ## ## [[3]] ## [1] &quot;numeric&quot; ## ## [[4]] ## [1] &quot;numeric&quot; De maneira genérica, é assim que são usados os parâmetros de map(): map(.x, .f, ...) # ou map(VETOR_OU_LISTA, FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) # que é equivalente a VETOR_OU_LISTA %&gt;% map(FUNCAO_PARA_APLICAR, ARGUMENTOS_OPCIONAIS) Existem duas maneiras de especificar a função para usar no map(): Uma função existente # definir uma lista composta por vetores v &lt;- list(v1 = c(1, 3, 5), v2 = c(2, 4, 6), v3 = c(7, 8, 9)) # aplicar a raiz quadrada a todos os vetores map(v, sqrt) ## $v1 ## [1] 1.000000 1.732051 2.236068 ## ## $v2 ## [1] 1.414214 2.000000 2.449490 ## ## $v3 ## [1] 2.645751 2.828427 3.000000 # calcular a soma dos elementos de cada vetor map(v, sum) ## $v1 ## [1] 9 ## ## $v2 ## [1] 12 ## ## $v3 ## [1] 24 Uma função “anônima”, definida dentro da própria map(). Veja que, em function(x) abaixo, x é como se fosse uma representação genérica de cada elemento da lista v. Em inglês isso se chama placeholder. # elevar cada elemento de cada vetor ao quadrado map(v, function(x) x^2) ## $v1 ## [1] 1 9 25 ## ## $v2 ## [1] 4 16 36 ## ## $v3 ## [1] 49 64 81 # elevar a soma dos elementos do vetor ao quadrado map(v, function(x) sum(x)^2) ## $v1 ## [1] 81 ## ## $v2 ## [1] 144 ## ## $v3 ## [1] 576 2.12 Case 1 Dada série de preços de 2 ativos: f * fazer gráfico com 2 ativos * calcular série de variação de preços dos ativos (retorno aritimético) - fazer gráfico do retorno * com retornos dos 2 ativos calcular série de índices (usando cumprod) para cada ativo - fazer gráfico comparando 2 ativos dá até pra criar uma série de taxa de juros fixa acumulada (simulando um CDI no período) 2.13 Case 2 Dada uma matriz de variação de preços de ativos calcular para cada ativo as estatísticas descritivas: média, desvio padrão, máximo, mínimo e mediana. Calcular o IBOVESPA: pegar, no site da B3, os ativos que constituem o IBOVESPA, os pesos e as cotações e calcular o valor do índice. "],
["fontes-de-dados-financeiros.html", "Capítulo 3 Fontes de dados financeiros 3.1 Pacotes 3.2 Manipulação de dados com xts e quantmod 3.3 Helpers do quantmod: Cl, Op, Hi, Lo 3.4 Funções de gráficos xts 3.5 Juntar múltiplas séries temporais: fazer merge das séries de fechamento. 3.6 Case", " Capítulo 3 Fontes de dados financeiros 3.1 Pacotes Alguns pacotes do R são ótimas fontes de dados financeiros, sem haver necessidade de buscar em fontes externas. library(quantmod) ## Warning: package &#39;quantmod&#39; was built under R version 4.0.2 ## Loading required package: xts ## Warning: package &#39;xts&#39; was built under R version 4.0.2 ## Loading required package: zoo ## Warning: package &#39;zoo&#39; was built under R version 4.0.2 ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## ## Attaching package: &#39;xts&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, last ## Loading required package: TTR ## Warning: package &#39;TTR&#39; was built under R version 4.0.2 ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo ## Version 0.4-0 included new data defaults. See ?getSymbols. library(rbcb) library(GetTDData) ## Warning: package &#39;GetTDData&#39; was built under R version 4.0.2 library(tidyverse) 3.1.1 quantmod: séries de preços de ações e índices O pacote quantmod é uma ótima ferramenta para obter dados de cotações de ações e índices. Funciona muito bem para o mercado brasileiro, apesar de, para alguns ativos, como ETF, existir alguns bugs. Possui a função getSymbols(), que utiliza a API do Yahoo Finance para obter os dados das cotações. Veja como pode ser usada: dolar &lt;- getSymbols(&quot;USDBRL=x&quot;, auto.assign = FALSE) ## &#39;getSymbols&#39; currently uses auto.assign=TRUE by default, but will ## use auto.assign=FALSE in 0.5-0. You will still be able to use ## &#39;loadSymbols&#39; to automatically load data. getOption(&quot;getSymbols.env&quot;) ## and getOption(&quot;getSymbols.auto.assign&quot;) will still be checked for ## alternate defaults. ## ## This message is shown once per session and may be disabled by setting ## options(&quot;getSymbols.warning4.0&quot;=FALSE). See ?getSymbols for details. ## Warning: USDBRL=x contains missing values. Some functions will not work if ## objects contain missing values in the middle of the series. Consider using ## na.omit(), na.approx(), na.fill(), etc to remove or replace them. Na tabela abaixo vemos uma amostra dos dados: head(dolar) ## USDBRL=X.Open USDBRL=X.High USDBRL=X.Low USDBRL=X.Close ## 2007-01-01 2.1310 2.1325 2.1310 2.1325 ## 2007-01-02 2.1335 2.1432 2.1295 2.1310 ## 2007-01-03 2.1310 2.1351 2.1278 2.1345 ## 2007-01-04 2.1345 2.1430 2.1345 2.1390 ## 2007-01-05 2.1390 2.1525 2.1345 2.1470 ## 2007-01-08 2.1485 2.1492 2.1425 2.1465 ## USDBRL=X.Volume USDBRL=X.Adjusted ## 2007-01-01 0 2.1325 ## 2007-01-02 0 2.1310 ## 2007-01-03 0 2.1345 ## 2007-01-04 0 2.1390 ## 2007-01-05 0 2.1470 ## 2007-01-08 0 2.1465 A função retornou uma tabela com colunas de preço de abertura, maior e menor preço do dia, preço de fechamento, volume negociado e preço ajustado (por conta de fatores como dividendos, split, etc). Na verdade, o objeto acima não é um data.frame. Veja a classe dele: class(dolar) ## [1] &quot;xts&quot; &quot;zoo&quot; O objeto é das classes xts e zoo, que eram muito usadas no passado. Atualmente, tem-se preferido usar dados na classe data.frame. Contudo, muitos pacotes ainda usam o xts como classe principal, sendo assim importante conhecer essas classes. Voltaremos a falar sobre xts em breve. Para obter cotações de uma ação do mercado brasileiro, deve-se usar o sufixo “.SA” com o código da ação. Além disso, pode-se alterar outros parâmetros da função, como a data de início da série, para modificar o objeto de retorno: itausa &lt;- getSymbols(&quot;ITSA4.SA&quot;, auto.assign = FALSE, from = &quot;2019-01-01&quot;, to = &quot;2020-01-02&quot;, periodicity = &quot;monthly&quot;) itausa ## ITSA4.SA.Open ITSA4.SA.High ITSA4.SA.Low ITSA4.SA.Close ## 2019-01-01 12.08 13.71 12.08 13.50 ## 2019-02-01 13.50 13.80 12.33 12.37 ## 2019-03-01 12.40 13.04 11.36 11.98 ## 2019-04-01 12.10 12.15 11.31 11.91 ## 2019-05-01 11.91 12.45 11.02 12.39 ## 2019-06-01 12.42 13.07 11.83 12.89 ## 2019-07-01 13.00 13.49 12.43 12.47 ## 2019-08-01 12.56 13.16 11.67 12.29 ## 2019-09-01 12.27 13.44 11.90 13.18 ## 2019-10-01 13.20 13.99 12.11 13.71 ## 2019-11-01 13.75 14.25 13.00 13.27 ## 2019-12-01 13.31 14.26 13.26 14.09 ## 2020-01-01 14.09 14.38 12.72 12.86 ## ITSA4.SA.Volume ITSA4.SA.Adjusted ## 2019-01-01 601458600 12.25150 ## 2019-02-01 717154000 11.22601 ## 2019-03-01 455097200 11.24800 ## 2019-04-01 371836700 11.20039 ## 2019-05-01 479823200 11.65179 ## 2019-06-01 498662200 12.12200 ## 2019-07-01 358912200 11.74598 ## 2019-08-01 533774500 11.57643 ## 2019-09-01 422719300 12.75404 ## 2019-10-01 391134100 13.28853 ## 2019-11-01 334994100 12.86206 ## 2019-12-01 338858800 13.65685 ## 2020-01-01 407079600 12.48894 3.1.2 rbcb: séries de preços de moedas: Mostrar helpers bid e ask O pacote rbcb foi criado para permitir que o R interaja com a API do Banco Central do Brasil, o Sistema Gerenciador de Séries Temporais (SGS). Para saber quais séries temporais podem ser obtidas com o pacote, recomenda-se ler a documentação do SGS. Vamos aos principais usos do pacote: Função get_series() Essa função é usada para baixar dados de uma série temporal. É necessário informar o código da série temporal na API do Bacen. Caso seja desconhecida, você pode usar a função search_series(): rbcb::search_series(&quot;dólar diário&quot;) ## ## Dataset: Taxa de câmbio - Livre - Dólar americano (venda) - diário ## Code: 1 ## Conceito: Para efeito das séries temporais, as taxas de câmbio foram agrupadas em dois módulos: I - Taxas administradas ou taxas livres, abrangendo todo o período, desde 1899 e,... ## URL: http://dadosabertos.bcb.gov.br/dataset/1-taxa-de-cambio---livre---dolar-americano-venda---diario ## ## Dataset: Taxas de Câmbio - todos os boletins diários ## Code: NA ## Conceito: ## Séries de boletins diários de taxas de câmbio disponíveis desde 2 de janeiro de 2002, para o euro, e desde 28 de novembro de 1984, para as demais moedas. Para o dólar,... ## URL: http://dadosabertos.bcb.gov.br/dataset/taxas-de-cambio-todos-os-boletins-diarios ## ## Dataset: Dólar comercial (venda e compra) - cotações diárias ## Code: NA ## Disponível desde 28.11.1984, refere-se às taxas administradas até março de 1990 e às taxas livres a partir de então (Resolução 1690, de 18.3.1990). As taxas administradas são... ## URL: http://dadosabertos.bcb.gov.br/dataset/dolar-americano-usd-todos-os-boletins-diarios ## ## 3 results ## Pagination 1 / 1 Vemos, portanto, que o código da série temporal do dólar é 1. Portanto, a usamos como input de get_series(): x &lt;- rbcb::get_series(code = c(dolar = 1)) class(x) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; tail(x) ## # A tibble: 6 x 2 ## date dolar ## &lt;date&gt; &lt;dbl&gt; ## 1 2020-12-02 5.23 ## 2 2020-12-03 5.16 ## 3 2020-12-04 5.17 ## 4 2020-12-07 5.10 ## 5 2020-12-08 5.09 ## 6 2020-12-09 5.11 Outro item interessante que pode ser baixado é o IPCA. Além disso, outros paràmetros da função podem ser manipulados: df_ipca &lt;- get_series(code = c(ipca = 433), start_date = &quot;2019-06-01&quot;, end_date = &quot;2019-12-01&quot;) df_ipca ## # A tibble: 7 x 2 ## date ipca ## &lt;date&gt; &lt;dbl&gt; ## 1 2019-06-01 0.01 ## 2 2019-07-01 0.19 ## 3 2019-08-01 0.11 ## 4 2019-09-01 -0.04 ## 5 2019-10-01 0.1 ## 6 2019-11-01 0.51 ## 7 2019-12-01 1.15 Também é possível baixar mais de uma série temporal em apenas uma chamada da função: inflacao &lt;- get_series(c(IPCA = 433, IGPM = 189), last = 12, as = &quot;tibble&quot;) Nesse caso, contudo, o objeto retornado é uma lista de data frames: class(inflacao) ## [1] &quot;list&quot; map(inflacao, class) ## $IPCA ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $IGPM ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; map(inflacao, head) ## $IPCA ## # A tibble: 6 x 2 ## date IPCA ## &lt;date&gt; &lt;dbl&gt; ## 1 2019-12-01 1.15 ## 2 2020-01-01 0.21 ## 3 2020-02-01 0.25 ## 4 2020-03-01 0.07 ## 5 2020-04-01 -0.31 ## 6 2020-05-01 -0.38 ## ## $IGPM ## # A tibble: 6 x 2 ## date IGPM ## &lt;date&gt; &lt;dbl&gt; ## 1 2019-12-01 2.09 ## 2 2020-01-01 0.48 ## 3 2020-02-01 -0.04 ## 4 2020-03-01 1.24 ## 5 2020-04-01 0.8 ## 6 2020-05-01 0.28 Caso você deseje que o objeto de output acima seja um tibble, pode-se usar a função customizada abaixo: df_inflacao &lt;- reduce(inflacao, left_join, by = &quot;date&quot;) head(df_inflacao) ## # A tibble: 6 x 3 ## date IPCA IGPM ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-12-01 1.15 2.09 ## 2 2020-01-01 0.21 0.48 ## 3 2020-02-01 0.25 -0.04 ## 4 2020-03-01 0.07 1.24 ## 5 2020-04-01 -0.31 0.8 ## 6 2020-05-01 -0.38 0.28 3.1.3 GetTDData: séries de preços do tesouro direto O pacote GetTDData facilita a obtenção de dados históricos do Tesouro Direto, que disponibiliza, em seu site, arquivos xlsx de seus ativos de renda fixa. Os ativos que podem ser baixados com o pacote são os dos códigos LFT, LTN, NTN-C, NTN-B, NTN-B Principal e NTN-F. No exemplo abaixo, obtemos ativo &lt;- &quot;LFT&quot; # baixar arquivo x &lt;- download.TD.data(ativo) ## ## Downloading html page (attempt = 1|10) ## Downloading file TD Files/LFT_2020.xls (1-19) Downloading... ## Downloading file TD Files/LFT_2019.xls (2-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2018.xls (3-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2017.xls (4-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2016.xls (5-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2015.xls (6-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2014.xls (7-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2013.xls (8-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2012.xls (9-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2011.xls (10-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2010.xls (11-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2009.xls (12-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2008.xls (13-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2007.xls (14-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2006.xls (15-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2005.xls (16-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2004.xls (17-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2003.xls (18-19) Found file in folder, skipping it. ## Downloading file TD Files/LFT_2002.xls (19-19) Found file in folder, skipping it. Veja que o código nos avisa que foi criada uma pasta chamada TD Files onde foram baixados os arquivos do ativo. Para importar esses arquivos para o R, usamos uma outra função do pacote: ## ## Reading xls data and saving to data.frame ## Reading File = TD Files/LFT_2002.xls ## Reading Sheet LFT 210104 ## Reading Sheet LFT 160205 ## Reading Sheet LFT 180106 ## Reading Sheet LFT 170107 ## Reading File = TD Files/LFT_2003.xls ## Reading Sheet LFT 210104 ## Reading Sheet LFT 160205 ## Reading Sheet LFT 180106 ## Reading Sheet LFT 170107 ## Reading Sheet LFT 180608 ## Reading File = TD Files/LFT_2004.xls ## Reading Sheet LFT 210104 ## Reading Sheet LFT 160205 ## Reading Sheet LFT 180106 ## Reading Sheet LFT 170107 ## Reading Sheet LFT 180608 ## Reading Sheet LFT 180309 ## Reading File = TD Files/LFT_2005.xls ## Reading Sheet LFT 160205 ## Reading Sheet LFT 180106 ## Reading Sheet LFT 170107 ## Reading Sheet LFT 180608 ## Reading Sheet LFT 180309 ## Reading Sheet LFT 170310 ## Reading File = TD Files/LFT_2006.xls ## Reading Sheet LFT 180106 ## Reading Sheet LFT 170107 ## Reading Sheet LFT 180608 ## Reading Sheet LFT 180309 ## Reading Sheet LFT 170310 ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading File = TD Files/LFT_2007.xls ## Reading Sheet LFT 170107 ## Reading Sheet LFT 180608 ## Reading Sheet LFT 180309 ## Reading Sheet LFT 170310 ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading File = TD Files/LFT_2008.xls ## Reading Sheet LFT 180608 ## Reading Sheet LFT 180309 ## Reading Sheet LFT 170310 ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading File = TD Files/LFT_2009.xls ## Reading Sheet LFT 180309 ## Reading Sheet LFT 170310 ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading File = TD Files/LFT_2010.xls ## Reading Sheet LFT 170310 ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading Sheet LFT 070315 ## Reading File = TD Files/LFT_2011.xls ## Reading Sheet LFT 160311 ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading Sheet LFT 070315 ## Reading Sheet LFT 070317 ## Reading File = TD Files/LFT_2012.xls ## Reading Sheet LFT 070312 ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading Sheet LFT 070315 ## Reading Sheet LFT 070317 ## Reading File = TD Files/LFT_2013.xls ## Reading Sheet LFT 070313 ## Reading Sheet LFT 070314 ## Reading Sheet LFT 070315 ## Reading Sheet LFT 070317 ## Reading File = TD Files/LFT_2014.xls ## Reading Sheet LFT 070314 ## Reading Sheet LFT 070315 ## Reading Sheet LFT 070317 ## Reading File = TD Files/LFT_2015.xls ## Reading Sheet LFT 070315 ## Reading Sheet LFT 070317 ## Reading Sheet LFT 010321 ## Reading File = TD Files/LFT_2016.xls ## Reading Sheet LFT 070317 ## Reading Sheet LFT 010321 ## Reading File = TD Files/LFT_2017.xls ## Reading Sheet LFT 070317 ## Reading Sheet LFT 010321 ## Reading Sheet LFT 010323 ## Reading File = TD Files/LFT_2018.xls ## Reading Sheet LFT 010321 ## Reading Sheet LFT 010323 ## Reading File = TD Files/LFT_2019.xls ## Reading Sheet LFT 010321 ## Reading Sheet LFT 010323 ## Reading Sheet LFT 010325 ## Reading File = TD Files/LFT_2020.xls ## Reading Sheet LFT 010321 ## Reading Sheet LFT 010323 ## Reading Sheet LFT 010325 class(lft) ## [1] &quot;data.frame&quot; head(lft) ## ref.date yield.bid price.bid asset.code matur.date ## 4 2002-01-07 0.0024 1263.01 LFT 210104 2004-01-21 ## 5 2002-01-08 0.0024 1263.90 LFT 210104 2004-01-21 ## 6 2002-01-09 0.0024 1264.79 LFT 210104 2004-01-21 ## 7 2002-01-10 0.0024 1265.67 LFT 210104 2004-01-21 ## 8 2002-01-11 0.0023 1266.82 LFT 210104 2004-01-21 ## 9 2002-01-14 0.0023 1267.71 LFT 210104 2004-01-21 3.2 Manipulação de dados com xts e quantmod Conforme foi mencionado, objetos retornados pelo pacote quantmod (e por outros importantes pacotes R para Finanças) são da classe xts, por isso é importante conhecer alguns principios básicos de manipulação de dados com o pacote xts. library(xts) Vamos voltar a usar um objeto dessa classe do pacote quantmod: itausa &lt;- getSymbols(&quot;ITSA4.SA&quot;, auto.assign = FALSE, from = &quot;2018-01-01&quot;, to = &quot;2020-01-01&quot;, periodicity = &quot;daily&quot;) ## Warning: ITSA4.SA contains missing values. Some functions will not work if ## objects contain missing values in the middle of the series. Consider using ## na.omit(), na.approx(), na.fill(), etc to remove or replace them. head(itausa) ## ITSA4.SA.Open ITSA4.SA.High ITSA4.SA.Low ITSA4.SA.Close ## 2018-01-02 9.88182 10.0273 9.86364 10.0273 ## 2018-01-03 9.98182 10.1818 9.94545 10.1455 ## 2018-01-04 10.17270 10.3636 10.15450 10.3364 ## 2018-01-05 10.33640 10.3545 10.22730 10.3545 ## 2018-01-08 10.30000 10.3455 10.25450 10.3455 ## 2018-01-09 10.35450 10.3545 10.17270 10.1818 ## ITSA4.SA.Volume ITSA4.SA.Adjusted ## 2018-01-02 14040950 8.440587 ## 2018-01-03 13498870 8.540083 ## 2018-01-04 14303520 8.700775 ## 2018-01-05 10845010 8.716013 ## 2018-01-08 11024750 8.708437 ## 2018-01-09 24859010 8.570640 Um objeto xts possui dois principais elementos: coredata: o vetor ou matriz referente aos dados. head(coredata(itausa)) ## ITSA4.SA.Open ITSA4.SA.High ITSA4.SA.Low ITSA4.SA.Close ITSA4.SA.Volume ## [1,] 9.88182 10.0273 9.86364 10.0273 14040950 ## [2,] 9.98182 10.1818 9.94545 10.1455 13498870 ## [3,] 10.17270 10.3636 10.15450 10.3364 14303520 ## [4,] 10.33640 10.3545 10.22730 10.3545 10845010 ## [5,] 10.30000 10.3455 10.25450 10.3455 11024750 ## [6,] 10.35450 10.3545 10.17270 10.1818 24859010 ## ITSA4.SA.Adjusted ## [1,] 8.440587 ## [2,] 8.540083 ## [3,] 8.700775 ## [4,] 8.716013 ## [5,] 8.708437 ## [6,] 8.570640 index: vetor referente às datas head(index(itausa)) ## [1] &quot;2018-01-02&quot; &quot;2018-01-03&quot; &quot;2018-01-04&quot; &quot;2018-01-05&quot; &quot;2018-01-08&quot; ## [6] &quot;2018-01-09&quot; 3.2.1 Funções úteis para objetos xts Para estimar a periocidade: periodicity(itausa) ## Daily periodicity from 2018-01-02 to 2019-12-30 Converter a periodicidade: # para anual to.yearly(itausa) ## Warning in to.period(x, &quot;years&quot;, name = name, ...): missing values removed from ## data ## itausa.Open itausa.High itausa.Low itausa.Close itausa.Volume ## 2018-12-28 9.88182 13.1182 8.51 12.08 5109065710 ## 2019-12-30 12.11000 14.2600 11.02 14.09 5488006700 ## itausa.Adjusted ## 2018-12-28 10.96283 ## 2019-12-30 13.68345 # para mensal head(to.monthly(itausa)) ## Warning in to.period(x, &quot;months&quot;, indexAt = indexAt, name = name, ...): missing ## values removed from data ## itausa.Open itausa.High itausa.Low itausa.Close itausa.Volume ## jan 2018 9.88182 12.2909 9.86364 12.0455 374224180 ## fev 2018 12.04550 13.1182 11.30000 11.9273 427770310 ## mar 2018 11.97270 12.7182 11.90000 12.5364 302971900 ## abr 2018 12.54550 12.6909 11.71820 12.3727 257677200 ## mai 2018 12.29090 12.2909 10.06360 10.2091 525804620 ## jun 2018 10.50000 10.6800 8.51000 9.1800 578588000 ## itausa.Adjusted ## jan 2018 10.139430 ## fev 2018 10.530005 ## mar 2018 11.080418 ## abr 2018 10.935729 ## mai 2018 9.023410 ## jun 2018 8.124683 # para trimestral head(to.quarterly(itausa)) ## Warning in to.period(x, &quot;quarters&quot;, indexAt = indexAt, name = name, ...): ## missing values removed from data ## itausa.Open itausa.High itausa.Low itausa.Close itausa.Volume ## 2018 Q1 9.88182 13.1182 9.86364 12.5364 1104966390 ## 2018 Q2 12.54550 12.6909 8.51000 9.1800 1362069820 ## 2018 Q3 9.16000 11.0500 9.13000 10.1000 1219208900 ## 2018 Q4 10.11000 12.6300 9.92000 12.0800 1422820600 ## 2019 Q1 12.11000 13.8000 11.36000 11.9800 1757291600 ## 2019 Q2 12.10000 13.0700 11.02000 12.8900 1350322100 ## itausa.Adjusted ## 2018 Q1 11.080418 ## 2018 Q2 8.124683 ## 2018 Q3 9.144828 ## 2018 Q4 10.962826 ## 2019 Q1 11.266219 ## 2019 Q2 12.141599 Para converter um xts para data.frame: head(fortify.zoo(itausa)) ## Index ITSA4.SA.Open ITSA4.SA.High ITSA4.SA.Low ITSA4.SA.Close ## 1 2018-01-02 9.88182 10.0273 9.86364 10.0273 ## 2 2018-01-03 9.98182 10.1818 9.94545 10.1455 ## 3 2018-01-04 10.17270 10.3636 10.15450 10.3364 ## 4 2018-01-05 10.33640 10.3545 10.22730 10.3545 ## 5 2018-01-08 10.30000 10.3455 10.25450 10.3455 ## 6 2018-01-09 10.35450 10.3545 10.17270 10.1818 ## ITSA4.SA.Volume ITSA4.SA.Adjusted ## 1 14040950 8.440587 ## 2 13498870 8.540083 ## 3 14303520 8.700775 ## 4 10845010 8.716013 ## 5 11024750 8.708437 ## 6 24859010 8.570640 3.3 Helpers do quantmod: Cl, Op, Hi, Lo O pacote quantmod possui funções para auxiliar a extração de dados de objetos retornados por getSymbols(): # Obter apenas a serie de fechamento head(Cl(itausa)) ## ITSA4.SA.Close ## 2018-01-02 10.0273 ## 2018-01-03 10.1455 ## 2018-01-04 10.3364 ## 2018-01-05 10.3545 ## 2018-01-08 10.3455 ## 2018-01-09 10.1818 # serie de abertura head(Op(itausa)) ## ITSA4.SA.Open ## 2018-01-02 9.88182 ## 2018-01-03 9.98182 ## 2018-01-04 10.17270 ## 2018-01-05 10.33640 ## 2018-01-08 10.30000 ## 2018-01-09 10.35450 # serie do maior preço do período head(Hi(itausa)) ## ITSA4.SA.High ## 2018-01-02 10.0273 ## 2018-01-03 10.1818 ## 2018-01-04 10.3636 ## 2018-01-05 10.3545 ## 2018-01-08 10.3455 ## 2018-01-09 10.3545 # serie de preços ajustados head(Ad(itausa)) ## ITSA4.SA.Adjusted ## 2018-01-02 8.440587 ## 2018-01-03 8.540083 ## 2018-01-04 8.700775 ## 2018-01-05 8.716013 ## 2018-01-08 8.708437 ## 2018-01-09 8.570640 3.4 Funções de gráficos xts Plotar um objeto xts é muito simples, basta usar a função plot(): plot(itausa) O pacote quantmod possui outras funções interessantes para produzir gráficos de ativos financeiros: chartSeries(itausa) # candleChart dos 30 últitmos dias de itausa: candleChart(tail(itausa, 30), type = &quot;candlesticks&quot;) Também é possível fazer rapidamente gráficos de indicadores de análise técnica: chartSeries(itausa) addSMA() addMACD() 3.5 Juntar múltiplas séries temporais: fazer merge das séries de fechamento. A função merge() é usada para juntar dois objetos xts em um só: petr3 &lt;- getSymbols(&quot;PETR3.SA&quot;, auto.assign = FALSE, from = &quot;2018-01-01&quot;, to = &quot;2020-01-01&quot;, periodicity = &quot;monthly&quot;) petr3 &lt;- Ad(petr3) bbdc &lt;- getSymbols(&quot;BBDC4.SA&quot;, auto.assign = FALSE, from = &quot;2018-01-01&quot;, to = &quot;2020-01-01&quot;, periodicity = &quot;monthly&quot;) bbdc &lt;- Ad(bbdc) ibov &lt;- getSymbols(&quot;^BVSP&quot;, auto.assign = FALSE, from = &quot;2018-01-01&quot;, to = &quot;2020-01-01&quot;, periodicity = &quot;monthly&quot;) ibov &lt;- Ad(ibov) portfolio &lt;- merge(petr3, bbdc, ibov) head(portfolio) ## PETR3.SA.Adjusted BBDC4.SA.Adjusted BVSP.Adjusted ## 2018-01-01 16.25078 31.00556 84913 ## 2018-02-01 21.70834 26.33308 85481 ## 2018-03-01 21.90526 26.84055 85366 ## 2018-04-01 23.09617 25.85108 86115 ## 2018-05-01 20.80812 21.82359 76754 ## 2018-06-01 18.24192 20.13566 72763 3.6 Case Calcular o IBOVESPA em Dólar Dicas : Obter ^BVSP com quantmod, obter USDBRL com rbcb usando preço de venda (Ask) e fazer a conversão do IBOVESPA em dólar. "],
["returns.html", "Capítulo 4 Análise de Retornos 4.1 Retornos simples 4.2 Retornos logaritimicos 4.3 Relação entre os retornos simples e logaritimicos 4.4 Porque formas diferentes de calcular os retornos? 4.5 Retorno esperado 4.6 Risco esperado 4.7 Exercícios - Análise de Retornos", " Capítulo 4 Análise de Retornos Vamos considerar os seguintes investimentos em ações: Investimento em WEGE3 a R$ 42,03 em junho/2020 e venda em julho/2020 a R$ 67,32, lucro de R$ 25,29 por ação em 2 meses. Investimento em OIBR3 a R$ 0,49 em abril/2020 e venda em junho/2020 a R$ 1,20, lucro de R$ 0,71 por ação em 3 meses. Investimento em VVAR3 a R$ 4,65 em abril/2020 e venda em setembro/2020 a R$ 17,87, lucro de R$ 13,22 por ação em 6 meses. Qual investimento tem o melhor retorno? O investimento em WEGE3 apresenta o melhor resultado financeiro, pois é o que paga o maior retorno por ação, R$ 25,29. Calculando o resultado percentual temos 100 * c( WEGE3 = (67.32 - 42.03) / 42.03, OIBR3 = (1.20 - 0.49) / 0.49, VVAR3 = (17.87 - 4.65) / 4.65 ) ## WEGE3 OIBR3 VVAR3 ## 60.17131 144.89796 284.30108 O retorno percentual no período total da VVAR3 foi o dobro da OIBR3 e o quatro vezes o da WEGE3. Se ainda considerarmos o prazo do investimento de forma linear, ou seja, dividindo o retorno percentual pelo prazo em meses do investimento, temos: meses &lt;- c(2, 3, 6) 100 * c( WEGE3 = (67.32 - 42.03) / 42.03, OIBR3 = (1.20 - 0.49) / 0.49, VVAR3 = (17.87 - 4.65) / 4.65 ) / meses ## WEGE3 OIBR3 VVAR3 ## 30.08565 48.29932 47.38351 O retorno por mês da OIBR3 é um pouco maior que o retorno da VVAR3, na prática muito próximos. O que podemos extrair desses exemplos? Há diversas formas de avaliar o resultado entregue por um investimento: financeiro, percentual, ajustado ao prazo e outras formas. retorno é um termo utilizado para fazer referência ao resultado de um investimento. Veremos nas próximas seções algumas formas de calcular o retorno de um investimento e como utilizar o retorno para fazer a análise de risco do investimento. O que são retornos? Os retornos (retornos financeiros) representam a variação no preço dos nossos investimentos. Exemplo: Variação do preço de fechamento do ETF BOVA11 entre 31-01-2020 e 30-09-2020. getSymbols(&quot;BOVA11.SA&quot;, from = &quot;2020-01-31&quot;, to = &quot;2020-10-01&quot;) ## [1] &quot;BOVA11.SA&quot; Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() ## [1] 108.90 91.05 Vamos calcular a variação total dos preços usando a função diff Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] -17.85 Entre as datas 31-01-2020 e 30-09-2020 o cotação do BOVA11 perdeu R$ 17,85, pois temos uma variação negativa. Essa é a variação total, simplismente a diferença dos preços em instantes de tempo diferentes. Exemplo: Variação da cotação do Dólar Americano em Reais entre 31-01-2020 e 30-09-2020. USDBRL &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2020-01-31&quot;, end_date = &quot;2020-10-01&quot;, as = &quot;xts&quot;) Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() ## [1] 4.2695 5.6407 Vamos calcular a variação total dos preços usando a função diff Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] 1.3712 Note que entre as datas 31-01-2020 e 30-09-2020 o cotação do Dólar Americano perdeu R$ 1,3712, pelo menos 1 ordem de grandeza menor que o BOVA11, em módulo. A variação total pode ser considerada uma medida de retorno, entretanto, ela está muito vinculada ao valor do ativo. Vamos considerar \\(P_t\\) o valor do ativo em um instante \\(t\\) qualquer. A variação deste ativo entre os instantes \\(t\\) e \\(t-1\\) é dada por: \\[ \\Delta P_t = P_t - P_{t-1} \\] Chamamos esta variação total de \\(\\Delta P_t\\) onde \\(t\\) representa um instante qualquer no tempo e \\(t-1\\) é o instante anterior na série. Em nosso exemplo \\(t\\) é a primeira data e \\(t-1\\) a segunda. Como observamos, no mesmo período, os dois ativos apresentam medidas muito diferentes, logo, com esta medida é difícil comparar os 2 ativos. Há duas formas de calcular os retornos de maneira que possamos comparar os investimentos. Retornos Simples: calculados a partir da variação percentual dos preços com referência ao valor inicial Retornos Logarítimicos: calculados a partir da variação do logarítimo dos preços Nas próximas seções vamos detalhar estes tipos de retornos e como calculá-los. 4.1 Retornos simples Os retornos simples são a variação percentual dos preços de um ativo. Do exemplo do BOVA11 temos a diferença dos preços nas datas 31-01-2020 e 30-09-2020. Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] -17.85 Dada a diferença, só precisamos dividir pelo preço inicial, na data 31-01-2020. diff_ &lt;- Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ini_price &lt;- Cl(BOVA11.SA)[&quot;2020-01-31&quot;] %&gt;% as.numeric() diff_ / ini_price ## [1] -0.1639118 O BOVA11 apresentou uma variação negativa de 16,39% no período. Usando os dados do Dólar Americano temos diff_ &lt;- Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ini_price &lt;- Ask(USDBRL)[&quot;2020-01-31&quot;] %&gt;% as.numeric() diff_ / ini_price ## [1] 0.3211617 O Dólar Americano apresentou uma variação positiva de 32,11% no período, aproximadamente o dobro da variação do BOVA11, em módulo. Colocando em equação, a variação percentual é dada pela divisão de \\(\\Delta P_t\\) pelo seu valor inicial, \\(P_{t-1}\\), dessa forma calculamos o retorno simples \\(R_t\\). \\[\\begin{equation} R_t = \\frac{\\Delta P_t}{P_{t-1}} = \\frac{P_t - P_{t-1}}{P_{t-1}} = \\frac{P_t}{P_{t-1}} - 1 \\tag{4.1} \\end{equation}\\] O cálculo do retorno simples para dois instantes de tempo é útil para cálculos isolados, na prática queremos calcular retornos compostos em diferentes períodos em sequência. Queremos responder a perguntas como: Para uma série de preços diários de um ativo, calculamos os retornos simples diários, qual é a média dos retornos diários no período? Para uma série de retornos diários de um ativo, como calcular o retorno mensal? Dado o retorno mensal, qual é o retorno médio diário? 4.1.1 Retornos Simples Multiperíodo Vamos calcular os retornos simples a partir de uma série de preços. Com uma série temporal no R calculamos a variação usando a função diff para a série do Dólar Americano entre as datas 01-09-2020 e 04-09-2020. USDBRL &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2020-09-01&quot;, end_date = &quot;2020-09-04&quot;, as = &quot;xts&quot;) %&gt;% Ask() merge( USDBRL %&gt;% setNames(&quot;P_t&quot;), diff(USDBRL) %&gt;% setNames(&quot;diff&quot;) ) ## P_t diff ## 2020-09-01 5.3732 NA ## 2020-09-02 5.3741 0.0009 ## 2020-09-03 5.3079 -0.0662 ## 2020-09-04 5.2848 -0.0231 O primeiro elemento do vetor de diferenças é um NA porque o cálculo das diferenças é entre o elemento corrente com o anterior e para o primeiro elemento não há um elemento anterior para realizar o cálculo, dessa forma o R mantém a estrutura de índices e indica que o resultado para o índice em questão não está disponível. Usamos setNames para renomear diff(USDBRL) que vem com o nome ask, que é o mesmo da série original. Isso é interessante e uma ótima alternativa para organizar a apresentação dos dados. Usamos também a função merge para juntar as séries de preço e diferenças. A série diff é a série de diferenças, logo, representa \\(\\Delta P_t\\). Para realizar este cálculo de \\(R_t\\) no R é necessário obter a série de \\(P_{t-1}\\). Isso pode ser feito com a função lag.xts da série temporal. merge( USDBRL %&gt;% setNames(&quot;P_t&quot;), lag.xts(USDBRL) %&gt;% setNames(&quot;P_t1&quot;), diff(USDBRL) %&gt;% setNames(&quot;diff&quot;) ) ## P_t P_t1 diff ## 2020-09-01 5.3732 NA NA ## 2020-09-02 5.3741 5.3732 0.0009 ## 2020-09-03 5.3079 5.3741 -0.0662 ## 2020-09-04 5.2848 5.3079 -0.0231 Note que essa função desloca a série tempora em 1 elemento adiante. Aqui a coluna P_t1 refere-se a \\(P_{t-1}\\). Uma boa forma de ler esse resultado é que em \\(t\\) igual a 2020-09-02, \\(P_{t-1}\\) é 5.3732, que é o valor de \\(P_t\\) quando \\(t\\) é 2020-09-01, ou seja, o instante anterior. Assim, o retorno \\(R_t\\) é calculado no R da seguinte maneira: (100 * diff(USDBRL) / lag.xts(USDBRL)) %&gt;% setNames(&quot;R_t&quot;) ## R_t ## 2020-09-01 NA ## 2020-09-02 0.0167498 ## 2020-09-03 -1.2318342 ## 2020-09-04 -0.4352004 Note a multiplicação por 100 no código R, isso ajuda a interpretar o resultado. De forma prática observamos que do segundo para o terceiro dia tivemos um retorno negativo de mais de 1% na cotação do dólar, por exemplo. Uma outra forma de calcular retornos simples é utilizando a função Return.calculate do pacote PerformanceAnalytics. 100 * Return.calculate(USDBRL, method = &quot;discrete&quot;) %&gt;% setNames(&quot;R_t&quot;) ## R_t ## 2020-09-01 NA ## 2020-09-02 0.0167498 ## 2020-09-03 -1.2318342 ## 2020-09-04 -0.4352004 Dessa forma calculamos os retornos simples para uma série temporal. Neste exemplo calculamos os retornos diários, pois a série é de cotações diárias. É comum trabalharmos com séries com períodos maiores como séries semanais, mensais ou anuais. Logo, utilizando ainda a série do Dólar Americano, vamos obter a série mensal de preços e desta série vamos obter a série de retornos mensais para o ano de 2019. USDBRL_2019 &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% Ask() USDBRL_2019_monthly &lt;- to.monthly(USDBRL_2019, indexAt = &quot;firstof&quot;) %&gt;% Cl() USDBRL_2019_monthly ## USDBRL_2019.Close ## 2018-12-01 3.8748 ## 2019-01-01 3.6519 ## 2019-02-01 3.7385 ## 2019-03-01 3.8967 ## 2019-04-01 3.9453 ## 2019-05-01 3.9407 ## 2019-06-01 3.8322 ## 2019-07-01 3.7649 ## 2019-08-01 4.1385 ## 2019-09-01 4.1644 ## 2019-10-01 4.0041 ## 2019-11-01 4.2240 ## 2019-12-01 4.0307 Note que aqui o argumento start_date = \"2018-12-31\", definimos dessa maneira para que a série de preços começe com os dados de dezembro/2018 e assim ao construirmos a série mensal para o cálculo dos retornos tenhamos o retorno de janeiro/2019. De outra forma teríamos o retorno de janeiro/2019 igual a NA. Agora, utilizando a função Return.calculate, vamos calcular os retornos simples para a série mensal de cotações do Dólar Americano. Return.calculate(USDBRL_2019_monthly, method = &quot;discrete&quot;) %&gt;% setNames(&quot;R_t&quot;) -&gt; USDBRL_2019_monthly_returns 100 * USDBRL_2019_monthly_returns ## R_t ## 2018-12-01 NA ## 2019-01-01 -5.7525550 ## 2019-02-01 2.3713683 ## 2019-03-01 4.2316437 ## 2019-04-01 1.2472092 ## 2019-05-01 -0.1165944 ## 2019-06-01 -2.7533179 ## 2019-07-01 -1.7561714 ## 2019-08-01 9.9232383 ## 2019-09-01 0.6258306 ## 2019-10-01 -3.8492940 ## 2019-11-01 5.4918708 ## 2019-12-01 -4.5762311 Visualizando os dados em um gráfico de barras. barplot(USDBRL_2019_monthly_returns * 100, las = 2, ylim = c(-5, 10)) Outra forma de visualização de toda a série com PerformanceAnalytics usando a função charts.Bar. get_currency(&quot;USD&quot;, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% Ask() %&gt;% Return.calculate(method = &quot;discrete&quot;) %&gt;% charts.Bar(main = &quot;Retornos do Dólar&quot;) 4.1.2 Entendendo os preços em função dos retornos Vimos com escrever os retornos em função dos preços, uma outra forma de entender os retornos simples é inverter a Eq.(4.1) e escrevê-la em termos do preço \\(P_t\\). \\[\\begin{equation} P_t = P_{t-1} (1 + R_t) = P_{t-1} + R_t P_{t-1} \\tag{4.2} \\end{equation}\\] O preço \\(P_t\\) pode ser interpretado como um choque do retorno \\(R_t\\) no preço \\(P_{t-1}\\). O retorno \\(R_t\\) está associado ao período entre os instantes \\(t\\) e \\(t-1\\), de forma análoga, \\(R_{t-1}\\) está associado aos instantes \\(t-1\\) e \\(t-2\\), e assim por diante para diferentes valores de \\(t\\). Por isso o retorno simples também é conhecido como retorno discreto, pois, para cada período entre instantes dois instantes de tempo temos um choque discreto associado a cada movimento dos preços. Note que na função Return.calculate temos o argumento method=\"discrete\". 4.1.3 Composição de retornos simples Vimos como obter a série de retornos a partir da série de preços de um ativo. Agora vamos ver como obter a série de preços a partir da série de retornos e para isso é necessário entender como compor os retornos. A composição de retornos ajuda a responder a pergunta: Dado que temos os retornos simples de dois meses consecutivos, qual é o retorno total nos dois meses? Para obter os retornos mensais partimos da série de preços diários, para obter os retornos de 2 meses podemos partir da série de preços de 2 meses, mas este período não possui uma função com to.monthly de forma que dificulta um pouco o trabalho. Contudo, podemos partir da série de retornos mensais e criar uma série de retornos bimestrais compondo os retornos mensais. Isso vale para dois meses e vale para \\(N\\) meses, podemos construir séries de retornos trimestrais, semestrais e assim por diante. Vamos começar com um exemplo estático. Da série USDBRL_2019_monthly_returns vamos pegar os retonos dos últimos 2 meses, novembro e dezembro de 2019. last(USDBRL_2019_monthly_returns * 100, 2) ## R_t ## 2019-11-01 5.491871 ## 2019-12-01 -4.576231 Em novembro/2019 tivemos um retorno de 5,49% e em dezembro/2019 um retorno negativo de -4,57%. O retorno total no período é dado pela equação \\[\\begin{equation} R_{nov-dez/19} = (1 + R_{nov/19})(1 + R_{dez/19}) - 1 \\tag{4.3} \\end{equation}\\] Dessa forma, no R, utilizamos a função prod para calcular o retorno composto para este período. Modo base R: 100 * (prod(1 + last(USDBRL_2019_monthly_returns, 2)) - 1) ## [1] 0.6643191 Modo tidyverse: last(USDBRL_2019_monthly_returns, 2) %&gt;% `+`(1) %&gt;% prod() %&gt;% `-`(1) %&gt;% `*`(100) ## [1] 0.6643191 O retorno total é de 0,66%, praticamente zero, devido a queda de dezembro. Mas de onde vem a Eq.(4.3)? Vamos demostrar. Temos os retonos \\(R_t\\) e \\(R_{t-1}\\) referentes aos meses de novembro e dezembro de 2019. Vamos começar escrevendo o preço \\(P_t\\) conforme a Eq.(4.2). \\[\\begin{equation} P_t = P_{t-1} (1 + R_t) \\end{equation}\\] Aqui temos o preço de dezembro/2019 (\\(t\\)) como função do preço de novembro/2019 (\\(t-1\\)). Vamos escrever \\(P_{t-1}\\) também segundo a Eq.(4.2) substituindo na equação acima. \\[\\begin{equation} P_t = P_{t-2} (1 + R_{t-1}) (1 + R_t) \\end{equation}\\] Agora temos o preço de dezembro/2019 (\\(t\\)) como função do preço de outubro/2019 (\\(t-2\\)) Temos também os retornos \\(R_t\\) e \\(R_{t-1}\\) compostos produzindo o retorno total no período de novembro-dezembro/2019. Para simplificar podemos escrever \\[\\begin{equation} P_t = P_{t-2} (1 + \\bar{R}_{2}) \\end{equation}\\] onde \\((1 + \\bar{R}_{2})\\) é o retorno total no período de dois meses. Generalizando para \\(N\\) meses (ou dias, ou anos) temos que o retorno total neste período é dado por: \\[\\begin{equation} (1 + \\bar{R}_{N}) = \\prod_{i=0}^{N-1} (1 + R_{t-i}) \\tag{4.4} \\end{equation}\\] Podemos calcular o retorno simples para todo o ano de 2019 utilizando a função prod. 100 * (prod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1) ## [1] 4.023433 Dessa forma descobrimos que no ano de 2019 o Dólar Americano teve uma valorização de 4,02%. Foi necessário utilizar o método na.trim para remover o NA do primeiro elemento do cálculo dos produtos acumulados. As funções cumsum, cumprod, cummax e cummin não possuem o argumento na.rm que exclui os elementos com NA da operação, como acontece com as funções sum, prod, max e min. Por este motivo é importante fazer este tratamento antes de executar estas funções. No R ainda calcular o calcular a série de retornos simples compostos usando a função cumprod: 100 * (cumprod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1) ## R_t ## 2019-01-01 -5.7525550 ## 2019-02-01 -3.5176009 ## 2019-03-01 0.5651905 ## 2019-04-01 1.8194487 ## 2019-05-01 1.7007329 ## 2019-06-01 -1.0994116 ## 2019-07-01 -2.8362754 ## 2019-08-01 6.8055125 ## 2019-09-01 7.4739341 ## 2019-10-01 3.3369464 ## 2019-11-01 9.0120780 ## 2019-12-01 4.0234335 4.1.4 Visualização de retornos compostos Vamos ver aqui algumas formas de visualizar os retornos acumulados que aparecem em diversos sites de comparação de ativos. Dados os retornos mensais USDBRL_2019_monthly_returns vamos ver um gráfico de barras simples usando o código acima. barplot(100 * (cumprod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1), las = 2, ylim = c(-5, 10)) É possível notar que o grande resultado para o ano do Dólar Americano ocorreu em julho/2019, após este mês ele ficou de lado mantendo esse resultado. Uma outra forma interessante de ver o resultado dos retornos acumulados no tempo é visualizar o gráfico de linha dos retornos acumulados chart.CumReturns(USDBRL_2019_monthly_returns, begin = &quot;axis&quot;, wealth.index = TRUE, main = &quot;Retornos Acumulados&quot;, legend.loc = &#39;topleft&#39;) Note que ao fim do período temos os mesmos 4,02% acumulados, apenas sendo consistente. Também podemos fazer para toda a série acumulada. get_currency(&quot;USD&quot;, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% Ask() %&gt;% Return.calculate(method = &quot;discrete&quot;) %&gt;% chart.CumReturns(begin = &quot;axis&quot;, wealth.index = TRUE, main = &quot;Retornos Acumulados&quot;, legend.loc = &#39;topleft&#39;) Mais interessante é comparar mais de 1 ativos, vamos pegar 3 moedas: USD, CNY e GBP. list(&quot;USD&quot;, &quot;CNY&quot;, &quot;GBP&quot;) %&gt;% map(get_currency, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% map(Ask) %&gt;% reduce(function(x, y) merge(x, y)) %&gt;% Return.calculate(method = &quot;discrete&quot;) %&gt;% chart.CumReturns(begin = &quot;axis&quot;, wealth.index = TRUE, main = &quot;Retornos Acumulados - Moedas x BRL&quot;, legend.loc = &#39;topleft&#39;) Outra abordagem interessante é poder usar as cores para destacar uma série específica. list(&quot;USD&quot;, &quot;CNY&quot;, &quot;GBP&quot;) %&gt;% map(get_currency, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% map(Ask) %&gt;% reduce(function(x, y) merge(x, y)) %&gt;% Return.calculate(method = &quot;discrete&quot;) %&gt;% chart.CumReturns(begin = &quot;axis&quot;, wealth.index = TRUE, main = &quot;Retornos Acumulados - Moedas x BRL&quot;, legend.loc = &#39;topleft&#39;, col = c(&#39;gray&#39;, &#39;red&#39;, &#39;gray&#39;)) 4.1.5 Retorno médio Outra pergunta interessante para se fazer aqui é: Tá ok, eu sei que o retorno simples para o Dólar Americano em 2019 foi de 10,37%, mas qual é o retorno mensal médio de 2019? Este seria o retorno que poderíamos comparar com outros investimentos que também apresentam retornos mensais, como a Poupança por exemplo. Sabendo que o retorno simples no período é dado pela Eq.(4.4), podemos considerar que os retornos \\(R_t\\) são constantes e iguais a \\(\\hat{R}\\). Assim teríamos, \\[\\begin{equation} \\begin{array}{lcr} (1 + \\bar{R}_{N}) &amp; = &amp; \\prod_{i=0}^{N-1} (1 + \\hat{R}) \\\\ &amp; = &amp; (1 + \\hat{R})^N \\end{array} \\end{equation}\\] Consequentemente temos \\[\\begin{equation} (1 + \\hat{R}) = (1 + \\bar{R}_{N})^{\\frac{1}{N}} \\tag{4.5} \\end{equation}\\] É uma média geométrica dos retornos simples \\[ 1 + \\hat{R} = \\left( \\prod_{i=0}^{N-1} (1 + R_{t-i}) \\right)^{\\frac{1}{N}} \\] Esta é a razão pela qual é incorreto calcular a média aritimética dos retornos simples. No R calculamos essa operação usando o operado de exponenciação ^. R_med &lt;- ( prod(1 + na.trim(USDBRL_2019_monthly_returns)) ) ^ (1/length(na.trim(USDBRL_2019_monthly_returns))) - 1 100 * R_med ## [1] 0.3292576 Obtemos 0,33% ao mês! Para efeito de comparação, vamos considerar a taxa SELIC (taxa básica de juros na economia), esta taxa é de 2,0% ao ano. Podemos calcular o seu equivalente mensal aplicando a mesma fórmula. SELIC &lt;- 0.02 SELIC_med &lt;- (1 + SELIC) ^ (1 / 12) - 1 100 * SELIC_med ## [1] 0.1651581 Temos 0,17%, aproximadamente a metade do retorno obtido com o Dólar Americano no ano de 2019. 4.2 Retornos logaritimicos Os retornos logaritimicos são dados pela diferença entre os logarítimos dos preços dos ativos. \\[\\begin{equation} r_t = \\log \\left( \\frac{P_t}{P_{t-1}} \\right) = \\log P_t - \\log P_{t-1} = p_t - p_{t-1} \\tag{4.6} \\end{equation}\\] No R fazemos como na equação acima, tiramos a diferença dos logaritimos dos preços \\(P_t\\) 100 * diff(log(USDBRL)) %&gt;% setNames(&quot;r_t&quot;) ## r_t ## 2020-09-01 NA ## 2020-09-02 0.01674839 ## 2020-09-03 -1.23948413 ## 2020-09-04 -0.43615012 Os valores são bastante próximos aos dos retornos simples. Também podemos usar a função Return.calculate do pacote PerformanceAnalytics para calcular os retornos logaritimicos, só que neste caso, passando o argumento method = \"log\". 100 * Return.calculate(USDBRL, method = &quot;log&quot;) %&gt;% setNames(&quot;r_t&quot;) ## r_t ## 2020-09-01 NA ## 2020-09-02 0.01674839 ## 2020-09-03 -1.23948413 ## 2020-09-04 -0.43615012 Como o termo retorno logaritimico é muito extenso pra escrever e falar, vamos usar com mais frequência o termo log-retorno. 4.2.1 Entendendo os preços em função dos retornos Invertendo a Eq.(4.6) para obter a equação dos preços, da mesma maneira que fizemos na Eq.(4.2), temos: \\[\\begin{equation} P_t = P_{t-1} \\exp\\left( r_t \\right) \\tag{4.7} \\end{equation}\\] 4.2.2 Composição dos log-retornos A composição dos log-retornos se dá da seguinte forma: \\[\\begin{equation} \\exp(\\bar{r}_{N}) = \\prod_{i=0}^{N-1} \\exp(r_{t-i}) = \\exp\\left(\\sum_{i=0}^{N-1} r_{t-i}\\right) \\end{equation}\\] Dessa forma temos que o log-retorno no período, \\(\\bar{r}_{N}\\), é dado pela soma dos retornos \\[\\begin{equation} \\bar{r}_{N} = \\sum_{i=0}^{N-1} r_{t-i} \\tag{4.8} \\end{equation}\\] No R podemos calcular o log-retorno no período usando a função sum. Usando a série de preços do Dólar Americano em 2019, temos: 100 * sum(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;), na.rm = TRUE) ## [1] 3.944601 Note que aqui usamos na.rm = TRUE para indicar para a função sum que os elementos com NA deve ser excluídos da amostra. A função mean também apresenta este argumento. Note que o log-retorno referente a 2019 é 3.94%, ligeiramente menor que o obtido com o retorno simples, que foi de 4,02%. Entretanto, estas duas abordagens são equivalentes, vamos ver isso em mais detalhes na Seção4.3. Podemos ainda no R calcular a série de log-retornos compostos usando a função cumsum, da mesma forma que fizemos com os retornos simples. 100 * cumsum(na.trim(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;))) ## USDBRL_2019.Close ## 2019-01-01 -5.9246468 ## 2019-02-01 -3.5809587 ## 2019-03-01 0.5635993 ## 2019-04-01 1.8030948 ## 2019-05-01 1.6864324 ## 2019-06-01 -1.1054998 ## 2019-07-01 -2.8772748 ## 2019-08-01 6.5839355 ## 2019-09-01 7.2078159 ## 2019-10-01 3.2824788 ## 2019-11-01 8.6288498 ## 2019-12-01 3.9446010 4.2.3 Log-retorno médio Voltando a pergunta: Tá ok, eu sei que o log-retorno para o Dólar Americano em 2019 foi de 9,87%, mas qual é o retorno mensal médio de 2019? Dado que o log-retorno para um período com múltiplos retornos é dado pela soma dos retornos, temos que o log-retorno médio é dado pela média aritimética dos log-retornos. \\[\\begin{equation} \\hat{r} = \\frac{1}{N} \\sum_{i=0}^{N-1} r_{t-i} \\tag{4.9} \\end{equation}\\] Utilizamos a função mean no R para calcular o log-retorno médio para uma série de retornos 100 * mean(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;), na.rm = TRUE) ## [1] 0.3287167 Obtivemos 0,33%, praticamente o mesmo resultado obtido com o retorno simples, que arredondado também ficou em 0,33%. 4.3 Relação entre os retornos simples e logaritimicos Como vimos anteriormente, os retornos simples e logaritimicos, são diferentes, mesmo quando se referem ao mesmo período. Bem, vamos ver aqui que são duas formulações equivalentes, pois ambas são obtidas a partir dos mesmos preços. Como \\(P_t\\) deve ser sempre o mesmo, independente do retorno que estamos utilizando, então, usando as Eqs.(4.2) e (4.7), podemos obter a relação entre os retornos simples e logaritimicos. \\[\\begin{equation} 1 + R_t = \\exp\\left( r_t \\right) \\tag{4.10} \\end{equation}\\] 4.4 Porque formas diferentes de calcular os retornos? Bem, faz sentido trabalhar com duas formas diferentes de calcular retornos? Honestamente, não! Entretanto, os retornos simples são mais intuitivos de serem utilizados nos cálculos de retornos, por outro lado os log-retornos são mais fáceis de manipular nos cálculos, principalmente devido ao fato de que podem ser somados. Devido a simplicidade de uso dos log-retornos, a grande maioria dos estudos de alocação de ativos e risco de investimentos utiliza os log-retornos. Nas próximas seções vamos abordar os conceitos de retorno esperado e risco esperado para ativos e veremos que a utilização de log-retornos é fundamental. 4.5 Retorno esperado O retorno esperado é equivalente ao retorno médio. Há diversas outras formas de estimar o retorno esperado, desde modelos matemáticos complexos até hipóteses bem fundamentadas sobre o comportamento dos ativos. Aqui vamos considerar a análise estatística em que, dada uma amostra de retornos, o retorno médio é um bom estimador para retornos futuros. Justamente por ser o valor médio, o mais comum, o esperado para essa amostra. Na estatística, a média aritimética é estimador para a média consistente para a média de uma amostra. Por esse motivo os log-retornos são utilizado para o cálculo do retorno esperado, pois são equivalentes a média aritimética dos retornos. \\[\\begin{equation} \\hat{r} = \\frac{1}{N} \\sum_{i=0}^{N-1} r_{t-i} \\end{equation}\\] A partir daqui vamos assumir que o retorno esperado é a média aritimética dos log-retornos. 4.5.1 Retornos anualizados Outro conceito importante é o de retorno anualizado. Primeiro: porque anualizar os retornos? No mercado financeiro é muito comum se trabalhar com taxas ao ano como a SELIC e o CDI, que são taxas básicas de juros e sempre são cotadas ao ano. Dessa forma, é interessante converter os retornos para uma base anual de maneira que seja possível comparar os retornos esperados com retornos de outros investimentos. Para calcular o retorno anualizado, multiplicamos o retorno esperado pela quantidade de períodos que temos em 1 ano. Por exemplo: retorno esperado diário - multiplicamos por 252, que é uma convenção adotada no mercado brasileiro que significa 252 dias úteis por ano. retorno esperado mensal - multiplicamos por 12, pois 1 ano tem 12 meses. Vamos utilizar a nossa série USDBRL_2019 com as cotações do Dólar Americano para 2019. Primeiro vamos calcular os retornos diários USDBRL_2019_daily_returns &lt;- Return.calculate(USDBRL_2019, method = &quot;log&quot;) USDBRL_2019_daily_mean_return &lt;- mean(USDBRL_2019_daily_returns, na.rm = TRUE) 100 * USDBRL_2019_daily_mean_return ## [1] 0.01559131 Note que o retorno diário para o USDBRL em 2019 foi de 0,0156%. Vamos multiplicá-lo por 252 para encontrar o retorno anualizado 100 * USDBRL_2019_daily_mean_return * 252 ## [1] 3.92901 Obtivemos 3,93% com retorno diário anualizado, ficou bastante próximo do retorno anual calculado com a composição dos retornos mensais que ficou em 3,94%. Utilizando os retornos mensais Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;) %&gt;% setNames(&quot;R_t&quot;) -&gt; USDBRL_2019_monthly_log_returns USDBRL_2019_monthly_mean_return &lt;- mean(USDBRL_2019_monthly_log_returns, na.rm = TRUE) 100 * USDBRL_2019_monthly_mean_return ## [1] 0.3287167 Multiplicando USDBRL_2019_monthly_mean_return por 12 para anualizar o retorno temos 100 * USDBRL_2019_monthly_mean_return * 12 ## [1] 3.944601 Novamente a estimativa do retorno anualizado ficou muito próximo dos valores já encontrados, 3,94%. A anualização dos retornos é muito útil para converter os retornos entre períodos diários, mensais e anuais com contas simples que podem produzir análises interessantes para comparação de investimentos. 4.6 Risco esperado Há diversas formas de calcular o risco esperado de um ativo. Aqui vamos considerar que a volatilidade dos log-retornos será a medida de risco esperado para o ativo. Para calcular a volatilidade precisamos calcular a variância dos log-retornos, que é dada pela fórmula: \\[ \\textrm{Var}(r_t) = \\frac{1}{N-1}\\sum_{i=0}^{N-1}\\left( r_{t-i} - \\bar{r} \\right)^2 \\] A volatilidade dos retornos é dada pela raiz quadrada da variância e representada por \\(\\sigma\\). \\[ \\sigma = \\sqrt{\\textrm{Var}(r_t)} \\] A volatilidade também é conhecida como desvio padrão dos retornos, na verdade é o contrário, mas a ordem dos fatores não altera o produto. A volatilidade é um conceito amplo para descrever o comportamento da dinâmica de um ativo. Há diversas formas de estimar a volatilidade, aqui estamos assumindo a raiz quadrada da variância amostral. Contudo, a volatilidade não é observada, diferente dos preços dos ativos e das taxas de juros, logo, sua estimação é sempre calcada em um conjunto de hipóteses. Em termos gerais, o objetivo de caracterizar o risco esperado em termos da volatilidade é que a partir dessa medida possamos definir perdas esperadas associadas a probabilidades. Ou mesmo que não defina-se uma perda esperada, conhecendo a volatilidade de diferentes ativos é possível comparar os ativos por uma métrica de risco esperado potencial. No R utilizamos a função sd (de standard deviation e assim com sum e mean também possui um argumento na.rm) 100 * sd(Return.calculate(USDBRL_2019, method = &quot;log&quot;), na.rm = TRUE) ## [1] 0.6971556 O desvio padrão tem uma relação direta com os retornos, eles estão na mesma unidade. Aqui temos uma volatilidade de 0,69% para um retorno esperado de 0,0156%. Já já vamos saber como avaliar se isso é bom ou ruim, comparado a que? Por esse motivo o desvio padrão é utilizado para definir um intervalo de confiança para o retorno esperado. Por ora vamos segurar um pouco aqui, mais adiante vamos trazer uma abordagem estatística sobre os retornos e vamos falar mais sobre o desvio padrão. 4.6.1 Volatilidade anualizada Da mesma maneira que anualizamos os retornos, é necessário anualizar a volatilidade para evitar que façamos comparações de maçãs com bananas. A conta aqui é menos direta então vou colocar direto a equação. Para anualizar volatilidade diária (obtida de retornos diários) multiplicamos por raiz quadrada de 252 (quantidade de dias úteis no ano). \\[\\begin{equation} \\sigma_a = \\sigma_d\\sqrt{252} \\end{equation}\\] Para anualizar volatilidade mensal multiplicamos por raiz quadrada de 12 (número de meses no ano) \\[\\begin{equation} \\sigma_a = \\sigma_m\\sqrt{12} \\end{equation}\\] No exemplo acima, temos a volatilidade diária, logo, para anualizar a volatilidade vamos multiplicar por \\(\\sqrt{252}\\). 100 * sd(Return.calculate(USDBRL_2019, method = &quot;log&quot;), na.rm = TRUE) * sqrt(252) ## [1] 11.067 Com a volatilidade anualizada podemos escrever que o retorno anualizado é de 3,9% com uma volatilidade de 11%. Nas próximas seções vamos entender como comparar ativos com diferentes medidas de risco e retorno. Uma alternativa usando o PerformanceAnalytics 100 * StdDev.annualized(Return.calculate(USDBRL_2019, method = &quot;log&quot;)) ## USD ## Annualized Standard Deviation 11.067 4.7 Exercícios - Análise de Retornos Obtenha as séries de preços ajustados de Petrobrás PN (PETR4.SA), Lojas Renner (LREN3.SA), Ambev (ABEV3.SA), da ETF BOVA11 (BOVA11.SA) e do Índice IBOVESPA (^BVSP), para o período de 2010-01-01 a 2020-01-01 (10 anos de dados). Use a função getSymbols passando os símbolos dados. Estas séries possuem valores faltantes NA, é necessário fazer o tratamento. Para cada uma destas séries faça: Limpeza dos dados faltantes Cálculo do log-retorno diário Cálculo do retorno esperado anualizado Cálculo da volatilidade esperada anualizada Com as séries dos exercício anterior, faça para cada uma delas: Limpeza dos dados faltantes Cálculo do log-retorno diário Dividir as séries em 5 períodos de 2 anos cada (lembre de usar a indexação dos objetos xts) e calcule as estatísticas: retorno esperado e volatilidade anualizados, para cada sub-período. O que você observa? As medidas permanecem constantes ao longo do tempo? Fazer a mesma análise para retornos diários simples - as medidas mudam substancialmente? Dica: calcule a volatilidade usando o desvio padrão dos retornos, não é exato, mas é uma boa aproximação. Obtenha as séries de preços de Banco Itaú PN (ITUB4.SA), VALE (LREN3.SA), da ETF IVVB11 (IVVB11.SA) (replica o índice S&amp;P 500), da ETF PIBB11 (PIBB11.SA) (replica o índice IBrX50), para o período de 2015-01-01 a 2020-01-01 (5 anos de dados). Use a função getSymbols passando os símbolos dados. Estas séries possuem valores faltantes NA, é necessário fazer o tratamento. Para cada uma destas séries faça: Limpeza dos dados faltantes Cálculo da série de preços mensais Cálculo do log-retorno mensal Cálculo do retorno esperado e volatilidade mensal Cálculo do retorno esperado e volatilidade anualizados Repira a análise do segundo exercício utilizando as moedas USD, EUR, CNY, GBP e CHF. Dica: as moedas podem ser obtidas com a função get_currency do pacote rbcb. Use a função list_currencies do rbcb para descobrir os paises dessas moedas. Avalie as características das moedas. Fazer gráfico de comparação de evolução de ativos. Usar a série do Magazine Luiza (MGLU3.SA) no período de 2015-01-01 até 2020-11-30 e comparar com: CDI acumulado no período IBOVESPA IPCA "],
["análise-de-risco.html", "Capítulo 5 Análise de Risco 5.1 Visualização dos Retornos 5.2 Análise Estatística dos Retornos 5.3 Medidas de Risco 5.4 Análise em Janela Móvel 5.5 Túnel de Volatilidade 5.6 Comparando Ativos 5.7 Exercícios - Análise de Risco", " Capítulo 5 Análise de Risco Acabamos de ver como trabalhar com retornos financeiros, qual a diferença entre retornos simples e log-retornos, porque é mais comum trabalharmos com os log-retornos e como calcular o retorno esperado e a volatilidade de ativos financeiros. Dando continuidade vamos entender o que fazer com tudo isso. Como fazer a análise de risco de ativos e como comparar ativos financeiros, levando em consideração o seu retorno esperado e a sua volatilidade (análise de risco e retorno). Vamos ver que, em geral, o retorno e o risco costumam caminhar juntos de forma que para obter maiores retornos em investimentos devemos estar dispostos a assumir mais risco. Se algum investimento promete maior retorno com menos risco, tome cuidado, pode ser uma fraude! 5.1 Visualização dos Retornos No Capítulo 4 vimos como calcular os retornos a partir da série de preços de um ativo financeiro, assim como calcular o seu retorno esperado e a sua volatilidade. Mas um ponto muito importante na análise de ativos financeiro é a observação dos dados. Dessa maneira, vamos dar uma passo para trás e introduzir uma análise qualitativa dos retornos que envolve a visualização dos log-retornos. Vamos começar obtendo a série de cotação de fechamento do índice IBOVESPA no período de 10 anos de 2010 a 2019. Para obter a série do índice vamos utiliza a função getSymbols do pacote quantmod. O símbolo do IBOVESPA é ^BVSP. IBOVESPA &lt;- getSymbols(&quot;^BVSP&quot;, from = &quot;2009-12-31&quot;, to = &quot;2019-12-31&quot;, auto.assign = FALSE) Como é fundamental ver os dados com os quais se está trabalhando, vamos visualizar a série do índice, pegando a série de cotações de fechamento. IBOVESPA %&gt;% Cl() %&gt;% autoplot() O que observamos? De 2010 até 2016, aproximadamente há uma tendência de queda. A partir de 2016 há uma forte tendência de alta. Agora vamos calcular os retornos das cotações de fechamento: IBOVESPA_rets &lt;- IBOVESPA %&gt;% Cl() %&gt;% log() %&gt;% diff() Vamos visualizar os retornos agora: IBOVESPA_rets %&gt;% autoplot() O que observamos? Oscilações tanto positivas quanto negativas Sem tendência Pontos extremos Quando temos pontos extremos podemos perceber uma aglomeração nesse sentido Observando os retornos do índice temos um sobe e desce errático, sem tendência, bem diferente da série do índice que claramente apresenta tendência. Essa ausência de tendência é uma característica fundamental da série de retornos. Na próxima seção vamos introduzir a análise estatística dos retornos e como ela pode nos ajudar na caracterização dessa variável. 5.2 Análise Estatística dos Retornos Uma forma de descrever os retornos é assumir que podem ser descritos como uma variável aleatória e assim usar a teoria da probabilidade para descrever o seu comportamento. A variável IBOVESPA_rets que tem a série de retornos é uma realização dessa variável aleatória, a qual vamos chamar de amostra aleatória. A partir dessa amostra realizamos a análise estatística dos retornos, onde vamos apresentar algumas métricas úteis para descrever a variável aleatória, e muito úteis para comparar diferentes varíaveis aleatórias. Pois se consideramos os retornos do IBOVESPA uma variável aleatória, os retornos no índice S&amp;P 500, por exemplo, também podem ser descritos como uma variável aleatória só que uma diferente do IBOVESPA. A descrição matemática de uma variável aleatória não será vista aqui, não é o objetivo. Entretanto, vamos apresentar algumas avaliações qualitativas que permitam caracterizar a variável aleatória e nos suportem na avaliação de risco dos ativos. 5.2.1 Estatísticas Descritivas São medidas resumo que são calculadas para qualquer amostra aleatória. São úteis para caracterizar e entender a amostra aleatória, assim como comparar variáveis aleatórias diferentes. São exemplos de estatísticas descritivas para uma amostra aleatória: a média, a mediana, alguns quartis e valores de mínimo e máximo. No R a função summary provê algumas estatísticas descritivas da nossa série de retornos do IBOVESPA summary(coredata(IBOVESPA_rets)) ## BVSP.Close ## Min. :-0.092107 ## 1st Qu.:-0.008163 ## Median : 0.000262 ## Mean : 0.000146 ## 3rd Qu.: 0.008523 ## Max. : 0.063887 ## NA&#39;s :23 Note que estas medidas ajudam a entender como a amostra está distribuída. Conhecendo os pontos de mínimo e máximo temos o intervalo de cobertura da amostra. No caso dos retornos diários do IBOVESPA temos um mínimo de -0,092107 e um máximo de 0,063887. Com isso podemos concluir que em um intervalo de 10 anos o pior retorno diário para o IBOVESPA foi de -9% e o seu maior retorno foi de 6%. Como os retornos são calculados com base no preço de fechamento, temos que eventualmente ao longo de um dia de negociação o índice pode ter sofrido uma queda superior a 9%, contudo, para o fechamento este é o pior resultado no período. O primeiro quartil, que marca 25% dos dados da amostra, está em -0,008163 indicando que um quarto dos dados da amostra está abaixo de -0,8%, de outra forma temos que 75% dos dados está acima de -0,8%, ou seja, em 75% dos dias da amostra os retornos foram superiores a -0,8%. A mediana é ligeiramente superior a média, na verdade quase o dobro, isso pode ser uma indicação de qua amostra é negativamente assimétrica, pois a mediana é o meio da amostra e a média o seu ponto médio. Todavia, os valores aqui de média e mediana são muito próximos de zero, dessa maneira, a análise persiste, mas eventualmente esse efeito não seja significativo. Além dessas medidas de posição, há também as medidas de dispersão. Já vimos no Capítulo 4 a variância e o desvio padrão (volatilidade) var(IBOVESPA_rets %&gt;% as.numeric(), na.rm = TRUE) ## [1] 0.0001973679 sd(IBOVESPA_rets, na.rm = TRUE) ## [1] 0.01404877 Mas temos também a assimetria (skewness), que indica o quão simétrica é a amostra em torno da média. Uma assimetria zero indica que a amostra é simétrica, a assimetria positiva indica uma amostra com maior peso para valores acima da média e assimetria negativa o oposto. skewness(IBOVESPA_rets, na.rm = TRUE) ## [1] -0.1643848 Conforme falamos na análise da mediana, a amostra apresentava uma assimetria negativa, e o skewness confirma essa hipótese. Outra medida interessante é a curtose (kurtosis). A curtose é sempre positiva e quanto maior a curtose maior a probabilidade de que eventos extremos ocorram. Como balisador usamos a curtose da distribuição Normal (Gaussiana) que é uma distribuição muito importante e aparece em diversos fenômenos. Para a distribuição Normal e curtose é 3, dessa maneira, se a amostra apresenta uma curtose maior que 3 ela tem probabilidade de eventos extremos maior do que uma distribuição Normal. kurtosis(IBOVESPA_rets, na.rm = TRUE, method = &quot;moment&quot;) ## [1] 4.945592 Como vemos os retornos do IBOVESPA apresentam uma curtose maior do que 3, logo, há uma probabilidade de eventos extremos maior do que uma distribuição Normal. Isso não é necessariamente bom ou ruim, porque os eventos extremos podem ser positivos ou negativos e apesar dos retornos extremos negativos serem indesejados, os retornos extremos positivos são altamente desejáveis. Para efeito de comparação, vamos calcular as estatísticas descritivas para uma amostra aleatória Normal com média e variância dos retornos do IBOVESPA. # aprox. 10 anos x &lt;- rnorm(2500, mean = mean(IBOVESPA_rets, na.rm = TRUE), sd = sd(IBOVESPA_rets, na.rm = TRUE)) c( summary(x), skewness = skewness(x), kurtosis = kurtosis(x, method = &quot;moment&quot;) ) ## Min. 1st Qu. Median Mean 3rd Qu. ## -0.0466034113 -0.0092204068 0.0002447111 0.0001913628 0.0093492860 ## Max. skewness kurtosis ## 0.0485846974 0.0394800800 3.0509902137 Note que na amostra Normal os pontos de mínimo e máximo são bem menores que na distribuição de retornos do IBOVESPA, esse é um efeito que pode ser explicado, pela curtose mais elevada da distribuição de retornos. 5.2.2 Histograma Um histograma é um gráfico que representa a distribuição construida a partir da amostra aleatória, é um gráfico da distribuição amostral. No PerformanceAnalytics temos a função chart.Histogram. IBOVESPA_rets %&gt;% chart.Histogram(breaks = 50, main = &quot;Histograma de retornos do IBOVESPA&quot;, show.outliers = TRUE, methods = &quot;add.normal&quot;, lwd = 1) O que observamos? Pico em torno de zero, região mais provável ou de maior frequência. Pontos distantes do zero, positivos e negativos, indicando a ocorrência de eventos extremos No geral, tipicamente simétrico, se ignorarmos os extremos. A análise estatística dos retornos é fundamental pra entendermos a amostra e fazer qualquer tratamento nos dados para corrigir distorções que eventualmente surjam nos dados. É fundamental visualizar os dados, calcular as estatísticas descritivas e as estatísticas de dispersão e visualizar o histograma dos retornos, se comparar com a distribuição Normal, melhor ainda. Esse processo contribui para aumentar a sensibilidade com os dados e o senso crítico ao inicial uma análise. 5.3 Medidas de Risco Vamos introduzir aqui algumas medidas de risco e utilizar alguns exemplos com o ativo BOVA11, que é um ETF (fundo negociado em bolsa) que reproduz o retorno do índice IBOVESPA. O BOVA11 não é exatamente, na vírgula, o índice IBOVESPA, mas é muito próximo do índice. Vamos criar as séries de preços do BOVA11, de retornos diários, de preços mensais e retornos mensais. BOVA11 &lt;- getSymbols(&quot;BOVA11.SA&quot;, to = &quot;2019-12-31&quot;, auto.assign = FALSE) BOVA11_rets &lt;- BOVA11 %&gt;% Cl() %&gt;% log() %&gt;% diff() BOVA11_monthly &lt;- BOVA11 %&gt;% Ad() %&gt;% to.period() BOVA11_monthly_rets &lt;- BOVA11_monthly %&gt;% Cl() %&gt;% log() %&gt;% diff() Vamos considerar um cenário onde eu tenho uma carteira com 1000 ações do BOVA11. A série de BOVA11 termina em dez/2019, e a cotação de fechamento é R$ 111,23, logo o patrimônio da carteira é R$ 111.230,00. BOVA11 %&gt;% last() %&gt;% Cl() ## BOVA11.SA.Close ## 2019-12-30 111.23 Dessa forma e para começarmos a discutir sobre as medidas de risco vou colocar algumas perguntas que precisam ser respondidas. Quanto eu (investidor) posso perder, em valor, para uma oscilação extrema do BOVA11 considerando o período de 1 mês? Qual a probabilidade de que eu sofra uma perda de mais de 5% em 1 mês? Qual a pior perda que eu posso sofrer no meu patrimônio? Essas são perguntas objetivas que passam pela cabeça de todos os investidores e na tentativa de respondê-las nós vamos abordar as medidas de risco que nos permitem quantificar os pontos levantados. 5.3.1 Value at Risk O Value at Risk (Valor em Risco - tradução livre) ajuda a responder a pergunta: Quanto eu (investidor) posso perder, em valor, para uma oscilação extrema do BOVA11 no período de 1 mês e sabendo que o valor do ativo é R$ 111.23? Para o horizonte de investimento de 1 mês, quanto pode ser uma oscilação extrema? É necessário definir o que vem a ser uma variação extrema neste horizonte de investimento Para isso vamos usar a série de retornos de 1 mês do BOVA11, pois é necessário que os retornos estejam ajustados ao horizonte de investimento definido, e vamos observar o seu histograma. BOVA11_monthly_rets %&gt;% chart.Histogram(breaks = 30, main = &quot;Histograma de retornos do IBOVESPA&quot;, show.outliers = TRUE, methods = &quot;add.normal&quot;, lwd = 1) O que observamos: os maiores retornos positivos ocorrem acima de 15% os maiores retornos negativos ocorrem abaixo de 10% o histograma para os dados mensais não se aproxima da distribuição Normal e há alguns buracos no histograma, isso se deve ao fato da amostra ter poucos dados - note que definimos breaks = 30 Observando o histograma vemos que as perdas extremas, abaixo de 10%, ocorrem com uma frequência muito baixa, pois estão na cauda da distribução. Sabendo que o desvio padrão de BOVA11_monthly_rets é aproximadamente 5%, temos que as maiores perdas estão abaixo de 2 desvios padrão. Isso é muito ou pouco? Para nos ajudar nessa análise vamos olhar a distribuição Normal na figura abaixo: Fonte: http://www.portalaction.com.br/probabilidades/62-distribuicao-normal Com 2 desvios padrão da média (centro da distribuição) temos, aproximadamente, 5% de probabilidade para as duas caudas, como a cauda negativa é a que nos interessa, temos 2,5% de probabilidade para perdas que estão abaixo de 2 desvios padrão. Conclusão: A probabilidade de perdas maiores que 2 desvios padrão é de 2,5%, quando utilizamos a distribuição Normal como proxy. Note que estamos fazendo uma aproximação considerando a distribuição Normal para chegarmos a essa probabilidade. Agora a pergunta é: dado que eu sei que a probabilidade de termos uma perda maior que 2 desvios padrão é de 2,5%, como calcular essa perda em financeiro? Para isso vamos usar a função qnorm que dada uma probabilidade ela retorna o valor associado, considerando uma distribuição Normal. Dado que temos a média e o desvio padrão dos retornos mensais, vamos plugar estes parâmetros na distribuição Normal para obter a perda associada a probabilidade de 2,5%. mu &lt;- BOVA11_monthly_rets %&gt;% na.omit() %&gt;% mean() sigma &lt;- BOVA11_monthly_rets %&gt;% na.omit() %&gt;% sd() qnorm(0.025, mean = mu, sd = sigma) ## [1] -0.1015289 Para essa amostra de retornos temos que a probabilidade de uma perda maior do que 10,15% é de 2,5%. De posse do retorno podemos aplicar a Eq.(4.7) para calcular a variação no preço para este retorno. Sabemos que último preço de BOVA11 é R$ 111,23, dessa forma a perda é dada por: r_t &lt;- qnorm(0.025, mean = mu, sd = sigma) P_t &lt;- 111.23 1000 * P_t * (1 - exp(r_t)) ## [1] 10738.7 Temos que para o horizonte de investimentos de 1 mês, a carteira com 1000 posições de BOVA11 tem um Value at Risk de R$ 10.738,70 com nível de confiança de 95%. Essa é a forma que se constuma ler o Value at Risk. 5.3.2 Drawdown Dado o histórico do BOVA11, qual a pior perda que eu posso sofrer no meu patrimônio? quanto tempo eu vou ficar amargando essa miséria? Na tentativa de responder essa pergunta usamos o drawdown. O drawdown é uma perda acumulada em uma sequência de perdas. Como se dá isso? As séries de retornos são bastante simétricas em torno de uma média, que é bem próxima de zero. Dessa maneira, podemos supor que em geral os retornos sobem e descem com a mesma probabilidade. Entretanto, existem períodos que ocorrem sequências de quedas e é isso que o drawdown mede, dada uma sequência de quedas: Quando ela começa? Quando termina ? Qual a magnetude da perda? No pacote PerformanceAnalytics tem algumas funções para trabalhar com drawdown. Vejamos o gráfico do drawdown para os retornos diários do BOVA11 no ano de 2019. chart.Drawdown(BOVA11_rets[&quot;2019&quot;]) Note que no gráfico as perdas começam, há uma recuperação, mas não suficiente para reverter o estado de perda. Quando puxamos os dados de drawdowns para o ano de 2019 (usando a função table.Drawdowns do PerformanceAnalytics) temos: table.Drawdowns(BOVA11_rets[&quot;2019&quot;]) ## From Trough To Depth Length To Trough Recovery ## 1 2019-03-19 2019-05-16 2019-06-21 -0.1057 66 41 25 ## 2 2019-07-11 2019-08-26 2019-10-22 -0.0937 74 33 41 ## 3 2019-02-05 2019-02-11 2019-03-13 -0.0433 23 5 18 ## 4 2019-11-08 2019-11-19 2019-12-04 -0.0322 17 7 10 ## 5 2019-01-28 2019-01-28 2019-02-01 -0.0224 5 1 4 Note que o maior drawdown gera uma perda de 10,57%, com uma duração de 66 dias, do começo até zerar a perda, a pior ponto acontece em 41 dias e após este ponto são 25 dias de recuperação. 5.3.3 Short-Fall Risk Vimos como quantificar a perda dado um nível de risco associado a uma probabilidade no cálculo do VaR, agora vamos inverter a análise, e vamos calcular a probabilidade de ter uma perda maior que um determinado valor. Ou seja, como calcular a probabilidade de um retorno cair abaixo de 5%? 100 * sum(BOVA11_rets &lt; -0.05, na.rm = TRUE) / length(BOVA11_rets) ## [1] 0.1603421 Para os retornos diários temos uma probabilidade de 0,16% de termos retornos menores que 5%. 100 * sum(BOVA11_monthly_rets &lt; -0.05, na.rm = TRUE) / length(BOVA11_monthly_rets) ## [1] 12.08791 Os retornos mensais apresentam uma probabilidade de 12,09% de probabilidade para retornos menores que 5%. 5.4 Análise em Janela Móvel Análise em janela móvel é útil para a avaliação da dinâmica temporal dos dados. Por exemplo, temos a série de retornos do IBOVESPA de 2010 a 2019 e podemos calcular a média e o desvio padrão para essa amostra. c( mean = IBOVESPA_rets %&gt;% na.omit %&gt;% mean(), sd = IBOVESPA_rets %&gt;% na.omit %&gt;% sd() ) ## mean sd ## 0.0001459989 0.0140487672 Uma pergunta que podemos fazer é, como se comporta a média e o desvio em uma janela móvel de 21 dias (tipicamente 1 mês em dias úteis). Vamos usar a função rollmean onde passamos a série e o tamanho da janela e ela retorna uma série com as médias para as janelas contíguas de 21 dias. rollmean(IBOVESPA_rets, 21) %&gt;% autoplot() + geom_hline(yintercept = IBOVESPA_rets %&gt;% na.omit %&gt;% mean(), colour = &#39;red&#39;) Marcando em vermelho a média da amostra completa, é interessante ver que há uma grande dispersão em torno desse valor e não há tendência clara de longo prazo, o que faz sentido (porque?). A mesma análise pode ser realizada com o desvio padrão. Neste caso usamos a função rollapply que recebe a série de retornos, o tamanho da janela e a função a ser aplicada a cada janela, aqui usaremos a função sd para cálculo do desvio padrão. rollapply(IBOVESPA_rets, 21, sd) %&gt;% autoplot() + geom_hline(yintercept = IBOVESPA_rets %&gt;% na.omit %&gt;% sd(), colour = &#39;red&#39;) Curioso ver que em 2011 e 2014/2015 tivemos picos mais pronunciados no desvio padrão, indicando momentos de maior volatilidade. 5.5 Túnel de Volatilidade Complementando a análise em janela móvel para os retornos, podemos também construir um túnel de volatilidade (ou envelope de volatilidade) que é útil para uma análise qualitativa dos retornos em conjunto com o desvio padrão em janela móvel. No gráfico abaixo fazemos o gráfico dos retornos com o túnel de volatilidade e fica bem evidente que nos períodos de 2011 e 2014/2015 tivemos umas aglomerações de retornos, indicando um período de crise onde retornos mais extremos, bastante distantes da média, podem ocorrer. plot(index(IBOVESPA_rets), coredata(IBOVESPA_rets), type = &quot;l&quot;, ylim = c(-0.1, 0.1), cex.axis = .7, lwd = 1, xlab = &quot;Date&quot;, ylab = &quot;Retorno&quot;, main = &quot;Retorno diário do IBOVESPA com intervalo de confiança de 2 desvios&quot;) volatility &lt;- rollapply(IBOVESPA_rets, 21, sd) lines(index(volatility), coredata(volatility) * 2, col = &quot;red&quot;) lines(index(volatility), -coredata(volatility) * 2, col = &quot;red&quot;) 5.6 Comparando Ativos Até aqui realizamos a análise de risco para apenas um ativo. Agora vamos utilizar esta análise univariada e vamos aplicar a diversos ativos para entender como diferentes ativos podem ser comparados entre si. Vamos utilizar uma série gráficos aqui que permitem uma análise conjunta dos ativos de forma que façamos uma análise de risco comparando os ativos entre si. 5.6.1 Comparação de risco e retorno de diversos ativos: gráfico de risco x retorno Vamos começar o gráfico risco x retorno, onde no eixo x é o risco e no y os retornos. Os passos são baixar as séries de preços dos ativos com o quantmod juntar as séries de diferentes ativos em um único objeto xts criar as séries mensais e calcular os retornos calcular médias e desvios padrão para cada um dos ativos montar o gráfico risco x retorno 5.6.1.1 Baixando as séries de preços As séries dos ativos contidas em symbols são baixadas e depois juntadas com a chamada reduce(merge). Essa é uma passagem tricky que vale a pena ser executada passo a passo para que seja bem compreendida. symbols &lt;- c(&quot;BOVA11.SA&quot;, &quot;SMAL11.SA&quot;, &quot;SPXI11.SA&quot;, &quot;PETR4.SA&quot;, &quot;VALE3.SA&quot;, &quot;B3SA3.SA&quot;, &quot;ABEV3.SA&quot;, &quot;ITUB4.SA&quot;, &quot;VVAR3.SA&quot;) prices &lt;- getSymbols(symbols, from = &quot;2016-01-01&quot;, to = &quot;2019-12-31&quot;, auto.assign = TRUE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) Obtidas as séries vamos ver o que temos em mãos. plot(prices, legend.loc = &quot;topleft&quot;) Nada demais, séries diferentes com diferentes ordens de grandeza, o que prejudica a avaliação. 5.6.1.2 Calculando dados mensais Usando a função to.monthly para obter as séries de preços mensais. prices_monthly &lt;- to.monthly(prices, indexAt = &quot;lastof&quot;, OHLC = FALSE) head(prices_monthly) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ABEV3.SA ## 2016-01-31 39.19 37.71 78.32 4.490080 8.315054 8.961099 16.52255 ## 2016-02-29 41.45 39.65 79.03 4.768392 10.102961 10.148924 15.72897 ## 2016-03-31 48.64 44.25 75.37 7.709209 12.960191 13.406712 16.76330 ## 2016-04-30 52.15 46.65 72.21 9.490397 16.843971 15.005033 17.28939 ## 2016-05-31 47.02 44.26 76.83 7.458729 12.164614 13.986295 17.03972 ## 2016-06-30 49.90 48.45 68.58 8.738958 13.918304 15.813653 16.98622 ## ITUB4.SA VVAR3.SA ## 2016-01-31 12.00107 1.232770 ## 2016-02-29 12.22963 2.236881 ## 2016-03-31 15.04177 2.405890 ## 2016-04-30 15.85434 2.953283 ## 2016-05-31 14.02242 2.585365 ## 2016-06-30 14.63821 3.082551 Obtidas as séries de preços mensais vamos seguir com o cálculo dos retornos usando a já conhecida Return.calculate. prices_monthly_rets &lt;- Return.calculate(prices_monthly, &quot;log&quot;) head(prices_monthly_rets) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA ## 2016-01-31 NA NA NA NA NA ## 2016-02-29 0.05606632 0.05016571 0.009024516 0.06013862 0.1947609 ## 2016-03-31 0.15995831 0.10976437 -0.047418157 0.48040645 0.2490539 ## 2016-04-30 0.06967800 0.05281760 -0.042830831 0.20786486 0.2621104 ## 2016-05-31 -0.10355118 -0.05259168 0.062016688 -0.24089542 -0.3254615 ## 2016-06-30 0.05944800 0.09045107 -0.113594239 0.15840594 0.1346736 ## B3SA3.SA ABEV3.SA ITUB4.SA VVAR3.SA ## 2016-01-31 NA NA NA NA ## 2016-02-29 0.12447481 -0.049222058 0.01886613 0.59581881 ## 2016-03-31 0.27838779 0.063687794 0.20696922 0.07283741 ## 2016-04-30 0.11263020 0.030900753 0.05261197 0.20499754 ## 2016-05-31 -0.07030776 -0.014545521 -0.12278563 -0.13305074 ## 2016-06-30 0.12279576 -0.003144956 0.04297763 0.17589080 5.6.1.3 Calculando média e desvio padrão Tendo um objeto com todos os retornos mensais vamos calcular a média para cada ativo com colMeans que calcula a média de cada coluna de uma matriz (em nosso caso um objeto xts). exp_returns &lt;- colMeans(prices_monthly_rets, na.rm = TRUE) exp_returns ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## 0.022195289 0.027360844 0.011658452 0.040536915 0.038657794 0.032656128 ## ABEV3.SA ITUB4.SA VVAR3.SA ## 0.002599821 0.023515050 0.046892935 O cálculo do desvio padrão utiliza a função StdDev do pacote PerformanceAnalytics. exp_risk &lt;- StdDev(prices_monthly_rets) exp_risk ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## StdDev 0.05495577 0.05394365 0.05235481 0.1269872 0.113819 0.08488673 ## ABEV3.SA ITUB4.SA VVAR3.SA ## StdDev 0.06119064 0.07817451 0.1760825 Com isso fechamos os indicadores de risco e retorno para cada um dos ativos. 5.6.1.4 Construindo o gráfico risco x retorno A parte mais fácil é construir os gráficos e utilizar os nomes dos ativos para identificá-los facilmente no gráfico. plot(exp_risk, exp_returns, xlim = c(0.05, 0.2), ylim = c(0.0, 0.05), pch = 16) text(x = exp_risk, y = exp_returns, labels = colnames(exp_risk), pos=4) Interessante aqui é ver uma small cap (ação de empresa com menor tamanho de mercado), VVAR3, dispontando com a maior risco e retorno, seguida de PETR4 e VALE3, duas consagradas blueships. Outra coisa curiosa, o SMALL11 (ETF de small caps) com um risco ligeiramente menor que BOVA11 e com maior retorno. Usando PerformanceAnalytics temos a função chart.RiskReturnScatter. chart.RiskReturnScatter(prices_monthly_rets) 5.6.2 Gráfico boxplot com retorno dos ativos O boxplot é uma forma de visualizar a dispersão dos dados e permite ainda a avaliação de pontos extremos na amostra, os outliers. Dado que possuimos uma amostra de retornos para cada ativo, podemos calcular um boxplot para cada ativo. Colocando tudo no mesmo gráfico nos permite comparar como os retornos dos ativos estão distribuidos. prices_monthly_rets %&gt;% data.frame(Date = index(.)) %&gt;% remove_rownames() %&gt;% gather(Symbol, Returns, -Date) %&gt;% ggplot(aes(x = Symbol, y = Returns)) + geom_boxplot() 5.6.3 Gráfico violinplot com as distribuições de retornos dos ativos O violinplot é muito semelhante ao boxplot. É um pouco mais fancy apesar de não deixar clara a existência de outliers, mas impressiona em um ppt. Brincadeiras a parte ele apresenta uma distribuição continua para cada ativo, o que permite identificar a simetria das distribuições dos retornos. prices_monthly_rets %&gt;% data.frame(Date = index(.)) %&gt;% remove_rownames() %&gt;% gather(Symbol, Returns, -Date) %&gt;% ggplot(aes(x = Symbol, y = Returns)) + geom_violin(fill = &quot;blue&quot;) 5.6.4 Correlação entre séries de retornos Concluindo a parte multivariada precisamos calcular a correlação entre os ativos, não poderia ficar de fora. A matriz de correlação é obtida com a função cor que retorna uma matrix quadrada com as correlações entre cada um dos pares de ativos e 1 na diagonal principal, como é uma matriz de correlação. cor(prices_monthly_rets %&gt;% na.omit()) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## BOVA11.SA 1.0000000 0.8719722 -0.47764813 0.8684556 0.4678069 0.7619350 ## SMAL11.SA 0.8719722 1.0000000 -0.51911630 0.6452371 0.3061980 0.6321611 ## SPXI11.SA -0.4776481 -0.5191163 1.00000000 -0.4666173 -0.1148997 -0.4768917 ## PETR4.SA 0.8684556 0.6452371 -0.46661726 1.0000000 0.4813710 0.6735395 ## VALE3.SA 0.4678069 0.3061980 -0.11489970 0.4813710 1.0000000 0.2238908 ## B3SA3.SA 0.7619350 0.6321611 -0.47689171 0.6735395 0.2238908 1.0000000 ## ABEV3.SA 0.4264350 0.4600609 -0.01728933 0.2039109 -0.0182789 0.3576270 ## ITUB4.SA 0.9113159 0.7489051 -0.47870759 0.7764732 0.3262518 0.6980961 ## VVAR3.SA 0.5137772 0.5543491 -0.32382206 0.2988384 0.2077724 0.4305646 ## ABEV3.SA ITUB4.SA VVAR3.SA ## BOVA11.SA 0.42643495 0.9113159 0.5137772 ## SMAL11.SA 0.46006094 0.7489051 0.5543491 ## SPXI11.SA -0.01728933 -0.4787076 -0.3238221 ## PETR4.SA 0.20391093 0.7764732 0.2988384 ## VALE3.SA -0.01827890 0.3262518 0.2077724 ## B3SA3.SA 0.35762698 0.6980961 0.4305646 ## ABEV3.SA 1.00000000 0.3439021 0.3857068 ## ITUB4.SA 0.34390212 1.0000000 0.3900220 ## VVAR3.SA 0.38570681 0.3900220 1.0000000 A matriz de covariância é calculada com a função cov. cov(prices_monthly_rets %&gt;% na.omit()) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA ## BOVA11.SA 0.003020137 0.002584975 -1.374289e-03 0.006060672 0.0029261381 ## SMAL11.SA 0.002584975 0.002909918 -1.466093e-03 0.004419971 0.0018799989 ## SPXI11.SA -0.001374289 -0.001466093 2.741026e-03 -0.003102253 -0.0006846843 ## PETR4.SA 0.006060672 0.004419971 -3.102253e-03 0.016125738 0.0069575226 ## VALE3.SA 0.002926138 0.001879999 -6.846843e-04 0.006957523 0.0129547701 ## B3SA3.SA 0.003554439 0.002894729 -2.119416e-03 0.007260435 0.0021631714 ## ABEV3.SA 0.001434007 0.001518591 -5.538853e-05 0.001584475 -0.0001273063 ## ITUB4.SA 0.003915142 0.003158147 -1.959260e-03 0.007708173 0.0029029063 ## VVAR3.SA 0.004971693 0.005265503 -2.985239e-03 0.006682091 0.0041640788 ## B3SA3.SA ABEV3.SA ITUB4.SA VVAR3.SA ## BOVA11.SA 0.003554439 1.434007e-03 0.003915142 0.004971693 ## SMAL11.SA 0.002894729 1.518591e-03 0.003158147 0.005265503 ## SPXI11.SA -0.002119416 -5.538853e-05 -0.001959260 -0.002985239 ## PETR4.SA 0.007260435 1.584475e-03 0.007708173 0.006682091 ## VALE3.SA 0.002163171 -1.273063e-04 0.002902906 0.004164079 ## B3SA3.SA 0.007205756 1.857612e-03 0.004632551 0.006435678 ## ABEV3.SA 0.001857612 3.744295e-03 0.001645073 0.004155837 ## ITUB4.SA 0.004632551 1.645073e-03 0.006111255 0.005368717 ## VVAR3.SA 0.006435678 4.155837e-03 0.005368717 0.031005042 A função chart.Correlation do PerformanceAnalytics traz um gráfico bem interessante e completo da correlação entre os ativos. chart.Correlation(prices_monthly_rets) Onde além dos valores de correlação também traz os níveis de significância de cada estivativa. Note que ABEV3 e VALE3 apresentam uma correlação muito baixa entre si, o que veremos no próximo capítulo, é uma boa característica quando falamos em diversificação. 5.7 Exercícios - Análise de Risco Para a série de preços da WEG (WEGE3.SA), calcular: Retornos diários logaritmicos Volatilidade em janela móvel Gráfico de túnel de volatilidade Para a série de retornos diários logaritmicos Fazer o gráfico do histograma Com a média e variância da amostra fazer o gráfico da densidade de probabilidade da distribuição normal. Comparar os gráficos. O histograma da amostra parece com uma distribuição normal? Calcular o VaR, Drawdown e Short-fall Risk para a Magazine Luiza (MGLU3.SA). "],
["análise-de-carteiras.html", "Capítulo 6 Análise de Carteiras 6.1 Carteira de ativos 6.2 Carteira com 2 ativos 6.3 Montando uma carteira 6.4 Rebalanceamento da carteira 6.5 Exercícios - Análise de Carteiras", " Capítulo 6 Análise de Carteiras Até agora em nossa jornada já vimos como calcular retornos financeiros, como fazer sua análise estatística e sua análise de risco, onde pudemos analisar diversos ativos e comparar levando em consideração o risco e retorno de cada um. Todos estes tópicos nos trazem a análise de carteira de ativos, onde analisamos o comportamento conjunto dos ativos e descobrimos como podemos utilizá-los conjuntamente para montar uma carteira com um risco menor do que se considerarmos o investimento nos ativos separadamente. Neste capítulo é necessário um pouco de teoria, mas garanto que já entramos nos códigos para entender como tudo isso se aplica. 6.1 Carteira de ativos Vamos considerar um exemplo simples onde temos um capital \\(W\\) para ser investido em dois ativos \\(P_1\\) e \\(P_2\\). Dessa maneira, investindo 100% do capital temos \\[\\begin{equation} n_1 P_1 + n_2 P_2 = W \\tag{6.1} \\end{equation}\\] que representa a carteira de ativos onde compramos \\(n_1\\) quantidades do ativo \\(P_1\\) e \\(n_2\\) quantidades de \\(P_2\\). No ato da compra o valor da carteira é \\(W\\), ignorando custos de transação e portanto, a fração \\(\\frac{n_1 P_1}{W}\\) é o percentual da carteira alocado no ativo \\(P_1\\) e \\(\\frac{n_2 P_2}{W}\\) é o percentual referente a \\(P_2\\). Podemos demostrar dividindo ambos os lados da Eq.(6.1) pelo capital \\(W\\). Logo temos: \\[\\begin{equation} \\begin{array}{rcl} \\frac{n_1 P_1 + n_2 P_2}{W} &amp; = &amp; \\frac{W}{W} \\\\ \\frac{n_1 P_1}{W} + \\frac{n_2 P_2}{W} &amp; = &amp; 1 \\\\ w_1 + w_2 &amp; = &amp; 1 \\\\ \\end{array} \\end{equation}\\] \\(w_1 = \\frac{n_1 P_1}{W}\\) e \\(w_2 = \\frac{n_2 P_2}{W}\\) representam os pesos dos ativos \\(P_1\\) e \\(P_2\\) na carteira. 6.1.1 Variação do valor da carteira em função dos retornos dos ativos Os ativos \\(P_1\\) e \\(P_2\\) variam com o tempo, podendo ter variações positivas e negativas. Vamos escrever a variação da carteira \\(W\\) em termo das varições dos ativos que constituem a carteira. \\[ dW = \\frac{\\partial W}{\\partial P1} dP_1 + \\frac{\\partial W}{\\partial P2} dP_2 \\] onde \\(\\frac{\\partial W}{\\partial P1}\\) e \\(\\frac{\\partial W}{\\partial P2}\\) são das variações da carteira em função da variação de cada ativo (do cálculo diferencial são as derivadas parciais da carteira \\(W \\equiv W(P_1, P_2)\\)). De acordo com a Eq.(6.1) temos: \\[\\begin{equation} \\begin{array}{rcl} \\frac{\\partial W}{\\partial P1} &amp; = &amp; n_1 \\\\ \\frac{\\partial W}{\\partial P2} &amp; = &amp; n_2 \\\\ \\end{array} \\end{equation}\\] Assim \\[\\begin{equation} \\begin{array}{rcl} dW &amp; = &amp; \\frac{\\partial W}{\\partial P1} dP_1 + \\frac{\\partial W}{\\partial P2} dP_2 \\\\ &amp; = &amp; n_1 dP_1 + n_2 dP_2 \\\\ &amp; = &amp; n_1 \\frac{P_1}{P_1} dP_1 + n_2 \\frac{P_2}{P_2} dP_2 \\\\ &amp; = &amp; n_1 P_1 \\frac{dP_1}{P_1} + n_2 P_2 \\frac{dP_2}{P_2} \\\\ &amp; = &amp; w_1 W \\frac{dP_1}{P_1} + w_2 W \\frac{dP_2}{P_2} \\\\ \\end{array} \\end{equation}\\] Dividindo os 2 lados da equação por \\(W\\) para obter as relações \\(\\frac{dx}{x} \\equiv d\\log x\\). \\[\\begin{equation} \\begin{array}{rcl} \\frac{dW}{W} &amp; = &amp; w_1 \\frac{dP_1}{P_1} + w_2 \\frac{dP_2}{P_2} \\\\ d\\log W &amp; = &amp; w_1 d\\log P_1 + w_2 d\\log P_2 \\\\ \\end{array} \\end{equation}\\] O termo \\(d\\log x\\) pode ser expandido para \\(\\log x_t - \\log x_{t-1}\\) que é a definição de log-retorno. Dessa maneira podemos escrever \\(d\\log W \\equiv r_W\\), \\(d\\log P_1 \\equiv r_1\\) e \\(d\\log P_2 \\equiv r_2\\), logo: \\[ r_W = w_1 r_1 + w_2 r_2 \\] Temos então que o log-retorno da carteira é dado pela soma dos retornos ponderados pelos pesos dos ativos na carteira. 6.2 Carteira com 2 ativos Seja uma carteira com 2 ativos, o retorno dessa carteira é dado pela soma dos retornos dos ativos multiplicados pelos seus respectivos pesos na carteira. \\[ r_{c,t} = w_1 r_{1,t} + w_2 r_{2,t} \\] onde os pesos \\(w_1\\) e \\(w_2\\) são restritos a: \\(w_1 + w_2 = 1\\): 100% da carteira está alocada nestes 2 ativos \\(w_1 \\ge 0\\) e \\(w_2 \\ge 0\\): vamos adimitir apenas posições compradas na carteira Da primeira restrição temos que \\[ w_2 = 1 - w_1 \\] logo, se fizermos \\(w_1 = \\alpha\\) temos \\[ \\begin{array}{rcl} w_1 &amp; = &amp; \\alpha \\\\ w_2 &amp; = &amp; 1 - \\alpha \\end{array} \\] Consequentemente, \\[ r_{c,t} = \\alpha r_{1,t} + (1 - \\alpha) r_{2,t} \\] 6.2.1 Retorno esperado da carteira \\[ \\bar{r}_{c} = \\alpha \\bar{r}_{1} + (1 - \\alpha) \\bar{r}_{2} \\] 6.2.2 Risco esperado da carteira A variância da carteira é dada por \\[ \\sigma^2_{c} = \\alpha^2 \\sigma^2_1 + (1-\\alpha)^2\\sigma^2_2+ 2 \\alpha (1 - \\alpha) \\sigma_1 \\sigma_2 \\rho_{12} \\] onde \\(\\sigma_1\\) e \\(\\sigma_2\\) são os desvios padrão dos ativos que compõem a carteira \\(\\rho_{12}\\) é a correlação entre os retornos \\(r_{1,t}\\) e \\(r_{2,t}\\) O risco da carteira é a raiz quadrada da variância da carteira \\(\\sigma_c = \\sqrt{\\sigma^2_c}\\). Note que as equações para \\(\\bar{r}_{c}\\) e \\(\\sigma_c\\) são função apenas de \\(\\alpha\\), uma vez que escolhidos os ativos, as variáveis \\(\\bar{r}_1\\), \\(\\bar{r}_2\\), \\(\\sigma_1\\), \\(\\sigma_2\\) e \\(\\rho_{12}\\) são obtidas dos próprios ativos. Dessa maneira, podemos simular o risco e retorno esperados da carteira para todos os valores de \\(\\alpha\\) no intervalo \\([0,1]\\). symbols &lt;- c(&quot;BOVA11.SA&quot;, &quot;SPXI11.SA&quot;) prices &lt;- getSymbols(symbols, from = &quot;2016-01-01&quot;, to = &quot;2019-12-31&quot;, auto.assign = TRUE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) prices %&gt;% head() ## BOVA11.SA SPXI11.SA ## 2016-01-04 41.10 82.35 ## 2016-01-05 41.18 83.00 ## 2016-01-06 40.50 81.65 ## 2016-01-07 39.47 80.25 ## 2016-01-08 39.34 79.50 ## 2016-01-11 38.72 78.49 Calculando o log-retorno dos ativos. rets &lt;- log(prices) %&gt;% diff() %&gt;% na.omit() head(rets) ## BOVA11.SA SPXI11.SA ## 2016-01-05 0.001944629 0.007862175 ## 2016-01-06 -0.016650727 -0.016398764 ## 2016-01-07 -0.025761059 -0.017295082 ## 2016-01-08 -0.003299102 -0.009389740 ## 2016-01-11 -0.015885525 -0.012785819 ## 2016-01-12 -0.008819772 0.006096844 Calculando retorno esperado anualizado, risco esperado anualizado para cada ativo e a correlação entre os ativos. r_i &lt;- colMeans(rets) * 252 r_i ## BOVA11.SA SPXI11.SA ## 0.2427106 0.1156337 sigma_i &lt;- apply(rets, 2, sd) * sqrt(252) sigma_i ## BOVA11.SA SPXI11.SA ## 0.2219144 0.1668333 rho_ij &lt;- cor(rets[,1], rets[,2]) %&gt;% as.numeric() rho_ij ## [1] -0.1240882 Montanto as funções para cálculo do retorno esperado e risco esperado (anualizados) da carteira com os 2 ativos. r_c &lt;- function(alpha, R) { # desanualizando R &lt;- R / 252 r &lt;- alpha*R[1] + (1 - alpha)*R[2] r * 252 } sigma_c &lt;- function(alpha, SIGMA, RHO) { # desanualizando SIGMA &lt;- SIGMA / sqrt(252) s &lt;- alpha * alpha * SIGMA[1] * SIGMA[1] + (1 - alpha) * (1 - alpha) * SIGMA[2] * SIGMA[2] + 2 * alpha * (1 - alpha) * SIGMA[1] * SIGMA[2] * RHO sqrt(s * 252) } Construindo o gráfico de risco e retorno com a fronteira eficiente com a correlação estimada entre os ativos. alpha &lt;- seq(0, 1, 0.01) risk_ &lt;- sigma_c(alpha, sigma_i, rho_ij) return_ &lt;- r_c(alpha, r_i) plot(risk_, return_, xlim = c(0.12, 0.25), type = &quot;b&quot;, pch=16, col = &quot;firebrick2&quot;, xlab = &quot;Risco&quot;, ylab = &quot;Retorno&quot;) text(x = sigma_i, y = r_i, labels=names(r_i), pos=4) points(x = sigma_i, y = r_i, col=&quot;orange3&quot;, pch=16, cex=1.5) Gráfico de risco e retorno com a fronteira eficiente assumindo uma correlação igual a 1 entre os ativos, ou seja, uma carteira sem diversificação. alpha &lt;- seq(0, 1, 0.05) risk_ &lt;- sigma_c(alpha, sigma_i, 1) return_ &lt;- r_c(alpha, r_i) plot(risk_, return_, xlim = c(0.12, 0.25), type = &quot;b&quot;, pch=16, col = &quot;firebrick3&quot;, xlab = &quot;Risco&quot;, ylab = &quot;Retorno&quot;) text(x = sigma_i, y = r_i, labels=names(r_i), pos=4) points(x = sigma_i, y = r_i, col=&quot;orange3&quot;, pch=16, cex=1.5) Gráfico de risco e retorno com a fronteira eficiente assumindo uma correlação igual a -1 entre os ativos, ou seja, uma carteira totalmente divesificada. alpha &lt;- seq(0, 1, 0.01) risk_ &lt;- sigma_c(alpha, sigma_i, -1) return_ &lt;- r_c(alpha, r_i) plot(risk_, return_, xlim = c(0, 0.27), type = &quot;b&quot;, pch=16, col = &quot;firebrick4&quot;, xlab = &quot;Risco&quot;, ylab = &quot;Retorno&quot;) text(x = sigma_i, y = r_i, labels=names(r_i), pos=4) points(x = sigma_i, y = r_i, col=&quot;orange3&quot;, pch=16, cex=1.5) Juntando as curvas de fronteira eficiente. # Totalmente diversificada (correlação = -1) alpha &lt;- seq(0, 1, 0.01) risk_ &lt;- sigma_c(alpha, sigma_i, -1) return_ &lt;- r_c(alpha, r_i) plot(risk_, return_, xlim = c(0, 0.27), type = &quot;p&quot;, pch=16, col = &quot;firebrick2&quot;, xlab = &quot;Risco&quot;, ylab = &quot;Retorno&quot;) # Correlação estimada entre os ativos alpha &lt;- seq(0, 1, 0.02) risk_ &lt;- sigma_c(alpha, sigma_i, rho_ij) return_ &lt;- r_c(alpha, r_i) points(risk_, return_, col = &quot;firebrick3&quot;, pch = 16) # Sem diversificação alpha &lt;- seq(0, 1, 0.05) risk_ &lt;- sigma_c(alpha, sigma_i, 1) return_ &lt;- r_c(alpha, r_i) points(risk_, return_, col = &quot;firebrick4&quot;, pch=16) # labels text(x = sigma_i, y = r_i, labels = names(r_i), pos = 4) points(x = sigma_i, y = r_i, col=&quot;orange3&quot;, pch = 16, cex = 1.5) 6.2.3 Selecionar a carteira de Mínima Variância risk &lt;- sigma_c(alpha, sigma_i, rho_ij) min_var_weight &lt;- alpha[which.min(risk)] min_var_weight ## [1] 0.4 6.3 Montando uma carteira weights_c &lt;- c(BOVA11.SA = min_var_weight, SPXI11.SA = 1 - min_var_weight) port_1 &lt;- Return.portfolio(rets, weights_c, wealth.index = TRUE) plot(port_1, main = &quot;Carteira de mínima variância&quot;) 6.3.1 O que acontece com os pesos dos ativos ao longo do tempo? Começamos a carteira com um \\(\\alpha\\) igual a 0.4. Logo temos 0.4 investidos em BOVA11 e 0.6 investidos em SPXI11. De acordo com a Eq.(6.1) as quantidades de cada ativo são atribuídos no instante da montagem da carteira, obedescendo pesos definidos. O que acontece se um ativo dobrar de valor e o outro ficar parado? Naturalmente os pesos dos ativos são alterados, pois as quantidades de cada ativo permanecem fixas. Logo, é necessário rebalancear a carteira para evitar que um ativo fique muito dominante na carteira, reduzindo a diversificação. Há diversas maneiras de fazer o rebalanceamento da carteira, uma forma bastante simples, embora não tanto eficaz, é fazer com que os ativos voltem a ponderação definida no instante inicial da carteira. Uma abordagem muito comum para investidores pessoa física é distribuir os ativos na carteira com pesos iguais e frequentemente fazer o rebalanceamento da carteira para enquadrar os pesos nesta regra. 6.4 Rebalanceamento da carteira weights_c &lt;- c(BOVA11.SA = min_var_weight, SPXI11.SA = 1 - min_var_weight) port_2 &lt;- Return.portfolio(rets, weights_c, rebalance_on = &quot;months&quot;, wealth.index = TRUE) ports &lt;- merge(port_1, port_2) %&gt;% `colnames&lt;-`(c(&quot;Sem rebalanceamento&quot;, &quot;Com rebalanceamento&quot;)) plot(ports, legend.loc = &quot;topleft&quot;, main = &quot;Simulando rebalanceamento da carteira&quot;) 6.5 Exercícios - Análise de Carteiras Escolha pares de ativos e faça: Análise de fronteira eficiente Pesos da carteira de mínima variância Retornos da carteira Retornos da carteira com rebalanceamento Cálculo do VaR e Drawdown da carteira com e sem rebalanceamento, tem diferença? "]
]
